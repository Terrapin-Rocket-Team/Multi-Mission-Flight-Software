{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This page written by ChatGPT. May not be accurate or helpful.</p>"},{"location":"#welcome-to-the-terrapin-rocket-teams-multi-mission-flight-software-mmfs-documentation","title":"Welcome to the Terrapin Rocket Team's Multi-Mission Flight Software (MMFS) Documentation","text":"<p>Welcome to the (maybe) official documentation site for TRT's Multi-Mission Flight Software (MMFS)\u2014the versatile and robust flight code framework developed by the Terrapin Rocket Team (TRT). Whether you're looking to integrate MMFS into your next mission, contribute to its ongoing development, or explore its unique capabilities, you've come to the right place!</p>"},{"location":"#what-is-mmfs","title":"\ud83d\ude80 What is MMFS?","text":"<p>MMFS is a modular and scalable flight software framework designed to meet the diverse needs of rocketry missions. Built with adaptability and reliability in mind, it provides a solid foundation for developing and deploying mission-critical systems. </p>"},{"location":"#explore-the-docs","title":"\ud83d\udcda Explore the Docs","text":"<p>This documentation is organized into three main sections to help you navigate the MMFS ecosystem:</p>"},{"location":"#1-getting-started","title":"1. Getting Started","text":"<ul> <li>Learn how to install MMFS and set it up as your base flight code framework.</li> <li>Step-by-step guides for configuring MMFS to meet your mission's requirements.</li> <li>Code snippets and examples to help you hit the ground running.</li> </ul>"},{"location":"#2-maintaining-mmfs","title":"2. Maintaining MMFS","text":"<ul> <li>Dive into the internals of MMFS to understand its architecture and core principles.</li> <li>Learn best practices for maintaining and updating the library.</li> <li>Contribution guidelines for those looking to improve MMFS.</li> </ul>"},{"location":"#3-miscellaneous-resources","title":"3. Miscellaneous Resources","text":"<ul> <li>Additional tools and utilities to enhance your development experience.</li> <li>Tips, tricks, and advanced usage scenarios.</li> <li>Frequently asked questions and troubleshooting.</li> </ul>"},{"location":"#features-at-a-glance","title":"\u2728 Features at a Glance","text":"<ul> <li>Modularity: Pick and choose components to fit your mission's needs.</li> <li>Scalability: From single-stage to multi-stage rockets, MMFS grows with your ambitions.</li> <li>Open Source: Join a community of rocketry enthusiasts and contribute to the future of MMFS.</li> </ul>"},{"location":"#ready-to-start","title":"\ud83c\udf1f Ready to Start?","text":"<p>Head over to the Getting Started section to begin your journey with MMFS. If you're a seasoned developer or contributor, check out the Maintaining MMFS section to dive deeper into the framework.</p> <p>Together, let's push the boundaries of rocketry innovation!</p>"},{"location":"maintainer-guide/","title":"Internal MMFS Maintenance Documentation","text":"<p>This section not yet completed.</p>"},{"location":"maintainer-guide/#maintaining-these-docs","title":"Maintaining these docs","text":"<ol> <li>die</li> <li>don't die</li> <li>??</li> <li>\\$$</li> </ol>"},{"location":"user-guide/basic-use/","title":"Basic Usage","text":"<p>Important!</p> <p>In order for PIO to recognize that you are working on a PIO project, you must open VSCode in the root directory of that project. that is, the directory that has the <code>platformio.ini</code> file in it. Without this, PlatformIO will not initialize and you will be unable to build or use proper Intellisense.</p>"},{"location":"user-guide/basic-use/#intro","title":"Intro","text":"<p>There are very few things that need to be done in order for the absolute minimum requirements to use MMFS to be met. You must: Extend the <code>State</code> class, pass it to an <code>MMFSSystem</code> object, and call the <code>init</code> and <code>update</code> methods during setup and loop, respectively. There are, of course, many more things that you can do to tailor MMFS to your preferences, but we'll start slow.</p>"},{"location":"user-guide/basic-use/#initial-integration","title":"Initial Integration","text":""},{"location":"user-guide/basic-use/#overriding-state","title":"Overriding <code>State</code>","text":"<p>Let's start by extending <code>State</code>. In your <code>src</code> folder, make a new set of files called something like <code>NewState.h</code> and <code>NewState.cpp</code>.</p> <p>Paste these contents into them:</p> NewState.hNewState.cpp <pre><code>#ifndef NEWSTATE_H\n#define NEWSTATE_H\n\n#include &lt;State/State.h&gt;\n\nusing namespace mmfs;\nclass NewState : public State {\n    public:\n        NewState(Sensor **sensors, int numSensors, Filter *filter);\n        void determineStage() override;\n};\n\n#endif\n</code></pre> <p><pre><code>#include \"NewState.h\"\n\nNewState::NewState(Sensor **sensors, int numSensors, Filter *filter) : State(sensors, numSensors, filter) {}\n\nvoid NewState::determineStage() // (1)!\n{\n    // Add whatever stage determination logic you'd like here.\n    // Here is one simplified example:\n    if (stage == 0 &amp;&amp; acceleration.z() &gt; 10 &amp;&amp; position.z() &gt; 20) \n    {                                                             // accelerating upwards and off the pad\n        stage = 1;                                                // ascent\n        getLogger().setRecordMode(FLIGHT);\n    }                                                             \n    else if (stage == 1 &amp;&amp; velocity.z() &lt; 0)                      // descending\n        stage = 2;                                                \n    else if (stage == 2 &amp;&amp; position.z() &lt; 20)                     \n    {                                                             // landed\n        stage = 3;\n        getLogger().setRecordMode(GROUND);\n    }\n}\n</code></pre></p> <ol> <li>You may have as many stages as you like, but MMFS expects you to have at least launch and land stages.</li> </ol> <p>Let's briefly talk about what we've done. <code>State</code> declares a method called <code>void determineStage()</code> that is called every time it updates. Only MMFS doesn't know which stages you might care about, so you have to tell it by overriding that function. The reason it's so important to detect launch and landing is because of those calls to <code>getLogger().setRecordMode()</code>. This changes the rate at which MMFS records data, but don't worry, we'll get to all of that. Just understand that this is an important method that must make those calls to <code>getLogger()</code> in order for data logging to work the way you want it to.<sup>1</sup></p>"},{"location":"user-guide/basic-use/#instantiating-the-state-object","title":"Instantiating the <code>State</code> object","text":"<p>Now that we have our <code>State</code> object with its <code>determineStage</code> method, we can head back over to the main file to finish our integration. We need to create an actual instance of the object for us to use in the <code>setup</code> and <code>loop</code> methods. You'll notice that in the constructor we implemented, it took a <code>Sensor **</code>. If you're not all that familiar with pointers, this is basically saying \"an array of pointers to <code>Sensor</code> objects\". This is because we need to pass in all of the sensors that we want to use. For now, let's just use the included 'IMU', 'GPS', and 'Barometer' sensors. We can do this by creating an array of pointers to <code>Sensor</code> objects, and then passing that to the <code>State</code> constructor. There was another important parameter, the <code>Filter</code>, which is a class that we haven't talked about yet. For now, we can just pass in <code>nullptr</code> for that parameter, as we don't need to use it right now.</p> main.cpp<pre><code>#include &lt;Arduino.h&gt;\n#include \"MMFS.h\"\n#include \"NewState.h\"\n\nMAX_M10S gps;\nDPS310 baro;\nBMI088andLIS3MDL imu9dof;\n\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nvoid setup()\n{\n\n}\n\nvoid loop()\n{\n\n}\n</code></pre> <p>Here we've used the sensors that come on the Avionics' sub-team's Sensor Board v1.1, which anyone else on the team is also welcome to use. If you need to implement your own sensors, you can check out the Sensor documentation for more information.</p>"},{"location":"user-guide/basic-use/#creating-an-mmfsconfig-object","title":"Creating an <code>MMFSConfig</code> object","text":"<p>Now, we need to create an <code>MMFSConfig</code> object, which is a neat little object that follows what's called a \"builder pattern\". This means that we can set all of the configuration options that we want, while leaving out the options we don't care about. For our use case, the only thing we need to send it is the state object, but we'll set up a couple other things as well so you get an idea of the object's versatility. Here's what that looks like:</p> main.cpp<pre><code>...\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nvoid setup()\n{\n...\n</code></pre> <p>So here, we're just setting the buzzer pin to 13 and the built-in LED pin to <code>LED_BUILTIN</code>, which is a constant that is defined in the Arduino framework. You can set any of the configuration options that you want by appending their methods to the end of the list, but for now, we'll just leave it at that. See the MMFSConfig documentation for more information.</p>"},{"location":"user-guide/basic-use/#creating-an-mmfssystem-object","title":"Creating an <code>MMFSSystem</code> object","text":"<p>Now that we have our config, we need ot actually create the <code>MMFSSystem</code> object. This is a simple one-liner:</p> main.cpp<pre><code>...\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nMMFSSystem system(config);\n\nvoid setup()\n{\n...\n</code></pre>"},{"location":"user-guide/basic-use/#calling-init-and-update","title":"Calling <code>init</code> and <code>update</code>","text":"<p>Now, we just need to call the <code>init</code> and <code>update</code> methods in the <code>setup</code> and <code>loop</code> methods, respectively. MMFS will take care of everything else. Yes, really. This is all the code you need to write to get a minimum working system up and running. </p> New codeFull main.cpp main.cpp<pre><code>MMFSSystem computer = MMFSSystem(&amp;config);\n\nvoid setup()\n{\n  computer.init();\n}\n\nvoid loop()\n{\n  computer.update();\n}\n</code></pre> <pre><code>#include &lt;Arduino.h&gt;\n#include \"MMFS.h\"\n#include \"NewState.h\"\n\nMAX_M10S gps;\nDPS310 baro;\nBMI088andLIS3MDL imu9dof;\n\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nMMFSSystem computer = MMFSSystem(&amp;config);\n\nvoid setup()\n{\n  computer.init();\n}\n\nvoid loop()\n{\n  computer.update();\n}\n</code></pre>"},{"location":"user-guide/basic-use/#conclusion","title":"Conclusion","text":"<p>That's it! You now have a fully functional MMFS system that is ready to be used. You can add more sensors, change the configuration options, and customize the <code>NewState</code> class to your heart's content. See the MMFSConfig documentation for more information on what you can do with the config object, and see the State documentation for more information on how to customize the state object.</p>"},{"location":"user-guide/basic-use/#easy-modifications","title":"Easy Modifications","text":"<p>Here are few easy modifications that you can make to the system to make it more suited to your needs. If you don't see what you're looking for here, try the page relating to that specific feature, or reach out to someone on Avionics.</p>"},{"location":"user-guide/basic-use/#modifying-the-update-rate","title":"Modifying the update rate","text":"<p>You can modify the update rate of the system by using one of two methods on the MMFS Config object. They both have the same effect, and the last one called is the one used.</p> withUpdateRate()withUpdateInterval() <pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUpdateRate(10); // 10Hz (100 ms between updates)\n</code></pre> <pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUpdateInterval(100); // 100ms between updates (10Hz)\n</code></pre> <p>Note</p> <p>10 hz is the default rate. If you set it too high, the system may struggle to keep up, so we recommend keeping it at 50 hz or lower.</p>"},{"location":"user-guide/basic-use/#sensor-drift-correction","title":"Sensor drift correction","text":"<p>While on the pad waiting for launch, it is very likely that the sensors will begin to drift slightly. There is a feature in MMFS that allows you to correct for this until launch is detected. This correction acts by averaging out some length of sensor data, while ignoring the very most recent data. As most launch detection systems require the rocket to be noticeably off the ground and may take a few iterations to properly detect launch, the idea behind this was to stop early launch data from affecting the zeroing of the sensors.</p> <p>Danger</p> <p>Using this feature requires that you have working launch detection. If not, they will continuously attempt to correct themselves to zero, and thus report faulty data for the duration of the flight.</p> <p><pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUsingSensorBiasCorrection(true); // (1)!\n                        .withSensorBiasCorrectionDataLength(2); // two seconds of data to average over, BUT\n                        .withSensorBiasCorrectionIgnore(1); // ignore the most recent 1 second of data.\n</code></pre></p> <ol> <li>This is false by default, however the length of collection and ignoring default to the two values below, meaning you do not have to call the methods if these values are fine for you.</li> </ol>"},{"location":"user-guide/basic-use/#using-blinkbuzz","title":"Using BlinkBuzz","text":"<p>As we saw earlier, you must add the signaling pins you want to use to the <code>MMFSConfig</code> object. This is done by calling the <code>withBuzzerPin()</code> and <code>withBBPin()</code> methods. The buzzer pin is special and has some default events that utilize it. <code>withBBPin()</code> can be use to add any pin (or a second buzzer). You can add up to 50 pins.</p> <p>To use a pin, you can call <code>bb.onoff(int pin, int duration, int repeat = 1, int pause = duration)</code>. If you are in the <code>loop</code> phase of the program, you can use <code>bb.aonoff(...)</code> to do the same thing asynchronously (i.e. beep for long periods without blocking other code execution).</p> <p>See the BlinkBuzz documentation for more usage information.</p>"},{"location":"user-guide/basic-use/#using-the-logger","title":"Using the Logger","text":"<p>You can modify the format of the event logger by using the <code>withLogPrefixFormatting()</code> method. This takes a string that must include the <code>$time</code> and <code>$logType</code> (case specific) keywords. It will then format all log entries accordingly. The default is </p> <p><code>\"$time - [$logType] \"</code></p> <p>To use the logger to record data, you can call <code>getLogger().recordLogData(LogType type, const char *format, ...)</code>. This will log the data to both the SD card and USB serial port.</p> <p>See the Logger documentation for more information.</p>"},{"location":"user-guide/basic-use/#conclusion_1","title":"Conclusion","text":"<p>This just scratches the surface of what these utilities and systems can handle (blink buzz can do infinite asynchronous morse code! ...if you need that).</p> <p>See the MMFSConfig documentation for more information on what you can do with the config object.</p> <p>See the State documentation for more information on how to customize the state object.</p> <p>Also check out the Event system, Sensor interface, DataReporter interface, and Filter interface for more information on how to use some more advanced parts of the system.</p> <ol> <li> <p>There are other configuration options that you can use to disregard the stage system, but we don't recommend it. Check out the Logger documentation for more information.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/faq/","title":"Frequently Asked Questions","text":"<p>Ask Drew or Michael on Slack :(</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>You may skip over this installation step if you are working in a repo that already uses MMFS and you are just looking to get introduced.</p> <p>Important!</p> <p>In order for PIO to recognize that you are working on a PIO project, you must open VSCode in the root directory of that project. that is, the directory that has the <code>platformio.ini</code> file in it. Without this, PlatformIO will not initialize and you will be unable to build or use proper Intellisense.</p>"},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following:</p> <ul> <li>Basic knowledge of C++ programming. (knowledge of what a pointer is and how to use one)</li> <li>VSCode and the PlatformIO (PIO) extension installed. [Installation Guide]</li> <li>Basic knowledge of VSCode and the PlatformIO interface [Interface cheat-sheet]</li> <li>Basic knowledge of Git and GitHub. [TRT Git/Github Guide]</li> <li>Access to a Teensy 4.1. </li> </ul>"},{"location":"user-guide/installation/#installation","title":"Installation","text":""},{"location":"user-guide/installation/#create-a-new-platformio-project","title":"Create a new PlatformIO project","text":"<p>Pick any folder to create it in, and create a new project. We strongly recommend choosing the arduino framework and the Teensy 4.1 board, as MMFS has not been tested on any other system.</p>"},{"location":"user-guide/installation/#modify-the-platformioini-file","title":"Modify the <code>platformio.ini</code> file","text":"<p>Add a dependency to MMFS by adding the highlighted lines to your <code>platformio.ini</code> file, found in your project's root directory. <pre><code>[env:teensy41]\nplatform = teensy\nboard = teensy41\nframework = arduino\nlib_deps =\n    https://github.com/Terrapin-Rocket-Team/Multi-Mission-Flight-Software.git#v3.0.0\n</code></pre></p> <p>Info</p> <p>You may add multiple dependencies by appending new indented lines under <code>lib_deps</code>.</p> <p>Tip</p> <p>We recommend always attaching the version specifier to the end of the url, as MMFS undergoes frequent breaking changes. For github links, this looks like <code>#{tag}</code>. We give our releases (a.k.a. tags) semantic versioning<sup>1</sup> numbers like <code>v3.0.0</code></p> <p>Now save the file. You should notice PIO start to download MMFS and all of its dependencies. It may take a few minutes.</p>"},{"location":"user-guide/installation/#add-mmfsh-to-maincpp","title":"Add <code>MMFS.h</code> to <code>main.cpp</code>","text":"<p>Looking at the folder structure, PIO should have created a <code>src</code> folder with a <code>main.cpp</code> in it. It has some basic example functions that you may ignore or delete. To link MMFS to this main file though, we need to <code>#include</code> it:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;MMFS.h&gt;\n\n// put function declarations here:\nint myFunction(int, int);\n</code></pre>"},{"location":"user-guide/installation/#build-the-project","title":"Build the project","text":"<p>The last thing to do to make sure that everything went well is to simply build the project.</p> <p>You can use any of PIO's <code>build</code> buttons to achieve this. If you don't know where the buttons are, we recommend using the toolbar on the bottom of the screen, where the <code>build</code> command is represented by the checkmark.</p> <p>The terminal should spit out <code>========[SUCCESS] Took ##.## seconds=======</code>. If not, first try and see if you can understand the error. If you get stuck, please feel free to message any of the club members with experience working in PlatformIO or MMFS.</p>"},{"location":"user-guide/installation/#conclusion","title":"Conclusion","text":"<p>That's all there is to installing the library. You're now ready to move on to using it! Hopefully that part will be just as straightforward.</p> <ol> <li> <p>We always use this format, but we don't always follow correct semantic versioning procedures.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/intro/","title":"The Complete MMFS User's Manual","text":"<p>Info</p> <p>These docs were written in the order shown on the sidebar. You many notice that later docs somewhat rely on the reader understanding topics covered earlier. They should mostly be self-sufficient, but it's not guaranteed.</p> <p>As always, if you have any questions, feel free to reach out on Slack or Github.</p> <p><sub><sup><sub><sup>Now on a cool new website!</sup></sub></sup></sub></p> <p>This is the official user's manual for TRT's Multi-Mission Flight Software (MMFS). It is designed to be a comprehensive guide for users of all levels, from beginners to advanced developers. The manual covers everything from installation and setup to advanced features and troubleshooting.</p> <p>The library is essentially split into two categories: Utilities and Interfaces. </p>"},{"location":"user-guide/intro/#utilities","title":"Utilities","text":"<p>We describe utilities as any part of the library designed to be used as-is, without the end user (you) having to overload or otherwise modify it. The utilities offered by MMFS are:</p>"},{"location":"user-guide/intro/#blinkbuzz","title":"BlinkBuzz","text":"<p>An (asynchronous!) utility for outputting patterned buzzes and LED blinks.</p>"},{"location":"user-guide/intro/#circbuffer","title":"CircBuffer","text":"<p>A queue or FIFO system for storing data in a fixed-size buffer.</p>"},{"location":"user-guide/intro/#logger","title":"Logger","text":"<p>A simple logging utility that can log to the SD card or USB serial port.</p>"},{"location":"user-guide/intro/#retrievedata","title":"RetrieveData","text":"<p>A system that allows transfer of flight data files over Serial, allowing retrieval of files stored in onboard flash.</p>"},{"location":"user-guide/intro/#math","title":"Math","text":"<p>A collection of ... math? ... objects (vectors, matrices, and quaternions) and their functions.</p>"},{"location":"user-guide/intro/#mmfssystem","title":"MMFSSystem","text":"<p>An object designed to handle all of the MMFS functions during flight.</p> <p>Most of the power that MMFS offers comes from the Logger and MMFSSystem utilities. That is to say, those are two of the most complicated systems in the library.</p>"},{"location":"user-guide/intro/#interfaces","title":"Interfaces","text":"<p>Interfaces are for any other part of the library that is not fully implemented, or otherwise is expected to be modified by the end user. Most of them are not strictly interfaces, but rather abstract classes. The following interfaces are offered by MMFS:</p>"},{"location":"user-guide/intro/#state","title":"State","text":"<p>This is the main purpose of using MMFS. It is an abstract class that is used to define the state of the rocket. It is designed to be overloaded by the end user, and is used to define the behavior of the telemetry systems during flight.</p>"},{"location":"user-guide/intro/#datareporter","title":"DataReporter","text":"<p>This is an interface for recording flight CSV data using Logger. State implements it, as do all of the sensors. You may extend it to add your own data reporters.</p>"},{"location":"user-guide/intro/#sensor","title":"Sensor","text":"<p>This is the base sensor interface. There are further interfaces for each type of sensor:</p> <ul> <li>Barometer</li> <li>IMU (9DOF, including accelerometer, gyroscope, and magnetometer)</li> <li>GPS</li> <li>Encoder (a motor encoder)</li> <li>LightSensor</li> </ul>"},{"location":"user-guide/intro/#event","title":"Event","text":"<p>This is a simple, readily-extendable event system. You can create classes that listen to and fire off custom events, or overload the handler for the default events.</p>"},{"location":"user-guide/intro/#filters","title":"Filters","text":"<p>This is a basic Kalman filter interface, able to be passed into State for it to use to filter sensor data.</p>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":"<p>idk ask Drew or Michael on Slack :(</p>"},{"location":"user-guide/ifaces/data-reporter/","title":"DataReporter","text":"<p>The DataReporter class is used by the Logger system in MMFS to log flight data from various sources. Each data reporter defines the variables to be recorded, the variable types, and the labels that appear in the output CSV file. This allows you to separate your flight data into multiple, self-contained objects that easily integrate with MMFS.</p>"},{"location":"user-guide/ifaces/data-reporter/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Column Definition    In your DataReporter subclass or instance, you\u2019ll define columns inside its constructor. You specify:</p> <ul> <li>The variable to record (by passing a pointer to it).</li> <li>The type of that variable (through the <code>PackedType</code> enum).</li> <li>The label to appear in the CSV header.</li> </ul> </li> <li> <p>Name and Uniqueness DataReporter objects can be given names in their constructors. If you do not specify a name, a unique one will be assigned using a static counter.</p> </li> <li> <p>Removal of Unneeded Columns    If you extend another DataReporter but want to remove one of its default columns, you can call <code>removeColumn(...)</code> in your subclass constructor or elsewhere.</p> </li> <li> <p>Auto-Packing     Data reporters will automatically package the data, but they do not come with an update step. You must write your own update step to update the data.</p> </li> </ol>"},{"location":"user-guide/ifaces/data-reporter/#usage-overview","title":"Usage Overview","text":"<p>Below is an example of how to create and use a custom DataReporter:</p> <p><pre><code>#include &lt;DataReporter.h&gt;\n\nusing namespace mmfs;\n\nclass MyCustomReporter : public DataReporter {\npublic:\n    // Constructor with an optional name\n    MyCustomReporter(const char* name = \"MyReporter\") \n        : DataReporter(name) \n    {\n        // Example variables to record\n        int altitude;        // You'd likely store this somewhere else in real code\n        float velocity;\n        double latitude; \n\n        // In the constructor, define the columns you want logged:\n        // addColumn(PackedType, pointerToVar, \"Label in CSV\")\n        addColumn(INT, &amp;altitude, \"Altitude\");\n        addColumn(FLOAT, &amp;velocity, \"Velocity\");\n        addColumn(DOUBLE_HP, &amp;latitude, \"Latitude\"); // (1)!\n    }\n\n    // Add your own update step here to modify the data.\n};\n</code></pre></p> <ol> <li>Use <code>DOUBLE</code> for 3 decimal point precision, or <code>DOUBLE_HP</code> if you want 7 points of precision. In this example, 3 decimal points of latitude is only accurate to about 100 meters, so we record all 7 for better location precision.</li> </ol>"},{"location":"user-guide/ifaces/data-reporter/#adding-columns","title":"Adding Columns","text":"<p>To add columns, call <code>addColumn()</code> or <code>insertColumn()</code> in your DataReporter constructor (or initialization method):</p> <ul> <li> <p><code>addColumn(PackedType t, T* variable, const char* label)</code>   Appends a new column with the given type, pointer to a variable, and the label that appears in the CSV header.  </p> </li> <li> <p><code>insertColumn(uint8_t place, PackedType t, T* variable, const char* label)</code>   Inserts a new column at a specific index.</p> </li> </ul>"},{"location":"user-guide/ifaces/data-reporter/#removing-columns","title":"Removing Columns","text":"<p>If you inherit from another DataReporter but do not want one of its columns, call:</p> <pre><code>removeColumn(\"UnwantedColumnLabel\");\n</code></pre> <p>This removes the column with label <code>\"UnwantedColumnLabel\"</code> from your final data set.</p>"},{"location":"user-guide/ifaces/data-reporter/#default-behavior","title":"Default Behavior","text":"<ul> <li>When you create a DataReporter without a name, it automatically assigns a unique name based on a static counter.</li> </ul>"},{"location":"user-guide/ifaces/data-reporter/#step-by-step-example","title":"Step-by-Step Example","text":"<p>Here\u2019s a simple step-by-step guide for beginners:</p> <ol> <li> <p>Create a custom reporter    Derive a new class from DataReporter. In your constructor, add the columns you want to record, with pointers to the variables that hold that data.</p> </li> <li> <p>Register it with MMFS    Pass your DataReporter object to the <code>MMFSConfig</code> object (via <code>withOtherDataReporters(...)</code>) or manually to the Logger if you\u2019re using a standalone approach.</p> </li> <li> <p>Let MMFS manage updates    Whenever <code>MMFSSystem::update()</code> (or an equivalent mechanism) is called, your reporter\u2019s most recent data is automatically logged as a CSV row. Keep in mind that MMFS and DataReporter do not update the data stored in those variables.</p> </li> <li> <p>Check CSV output    After a flight (or test run), retrieve the <code>.csv</code> file and confirm your new columns (Altitude, Velocity, etc.) appear as expected with the correct data.</p> </li> </ol>"},{"location":"user-guide/ifaces/data-reporter/#summary","title":"Summary","text":"<ul> <li>DataReporter objects act as modular data sources for logging in MMFS.</li> <li>You specify a name, define columns for logging, and let MMFS handle how and when the data is stored or transmitted.</li> </ul> <p>Use this class to easily add flight data logging to your project, keeping your code organized and your flight logs detailed.</p> <p>Written by ChatGPT. Information may not be completely accurate.</p>"},{"location":"user-guide/ifaces/event/","title":"Events","text":"<p>Events in MMFS allow you to respond to system-wide actions or notifications. By default, these events are used to coordinate various parts of the library (e.g., logging, GPS, state changes). You can also create your own events or custom listeners to handle specific needs.</p>"},{"location":"user-guide/ifaces/event/#core-components","title":"Core Components","text":"<ol> <li> <p><code>Event</code>     A simple class carrying an EventID. Developers can create new event types by inheriting from <code>Event</code> and adding any additional data they want to share with listeners.</p> </li> <li> <p><code>IEventListener</code>     An interface that you can inherit from to automatically subscribe to all events in MMFS. Each <code>IEventListener</code> must implement:     <pre><code>void onEvent(const Event *e) override;\n</code></pre>     Inside this function, you decide how to handle any event passed to you.</p> </li> <li> <p><code>EventManager</code>     The main system responsible for event dispatch. It tracks all active <code>IEventListener</code> objects and calls their <code>onEvent()</code> methods whenever an event is invoked.</p> </li> </ol>"},{"location":"user-guide/ifaces/event/#how-it-works","title":"How It Works","text":"<ol> <li>Event Creation     An event in MMFS has a unique numeric ID. You can either:<ul> <li>Directly specify an integer ID, or</li> <li>Use the handy compile-time hashing of a string literal with <code>\"SOME_TEXT\"_i</code>.</li> </ul> </li> </ol> <p>For instance:    <pre><code>// Produces a unique integer ID at compile time\nstatic const EventID MY_CUSTOM_EVENT = \"MY_CUSTOM_EVENT\"_i;\n</code></pre></p> <ol> <li>Subscribing to Events    Whenever you create a class that inherits from <code>IEventListener</code>, its constructor automatically subscribes you to the global event manager. You do not need to manually register anything, unless you want to manually manage subscription/unsubscription.</li> </ol> <p>You may also manually subscribe/unsubscribe specific global functions (not class methods) by calling</p> <pre><code>getEventManager().subscribe(funcName);\n</code></pre> <ol> <li> <p>Dispatching Events    Any code can invoke an event by calling:    <pre><code>getEventManager().invoke(yourEventObject);\n</code></pre>    All active <code>IEventListener</code> objects will receive this event through their <code>onEvent()</code> method.</p> </li> <li> <p>Handling Events    Since every listener hears every event, you typically use an <code>if</code> or <code>switch</code> statement based on the event\u2019s ID, or perform a dynamic cast if you\u2019re dealing with a custom event type. For example:    <pre><code>void onEvent(const Event *e) override {\n    switch (e-&gt;ID) {\n        case \"LOG_DATA\"_i:\n            // Handle log data event\n            break;\n\n        case \"GPS_FIX\"_i:\n            // Handle GPS fix event\n            break;\n\n        default:\n            // Ignore or handle other events\n            break;\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"user-guide/ifaces/event/#default-events","title":"Default Events","text":"<p>MMFS provides a few built-in events for common scenarios:</p> <ul> <li> <p><code>GPSFix</code>   Notifies listeners when a GPS fix occurs or changes. It carries a pointer to the <code>GPS</code> object and a boolean indicating if this is the first time a fix has been acquired since boot.</p> </li> <li> <p><code>LogData</code>   Fired when new log data is recorded. Carries information about the log destination (<code>SD</code> vs. <code>USB</code>), the log type (e.g., <code>INFO_</code>, <code>ERROR_</code>), and the actual string message.</p> </li> <li> <p><code>BoolEvent</code>   A simple true/false style event used for various system checks (e.g., initialization success).</p> </li> </ul>"},{"location":"user-guide/ifaces/event/#default-event-handler","title":"Default Event Handler","text":"<p><code>DefaultEventHandler</code> is a built-in class that inherits from <code>IEventListener</code> and implements <code>onEvent()</code>. It provides out-of-the-box handling for:</p> <ul> <li>GPS fixes</li> <li>Log data notifications</li> <li>Initialization events</li> </ul> <p>If you need to change how these events are processed, you can subclass <code>DefaultEventHandler</code> and override its methods: <pre><code>void onEvent(const Event *event) override {\n    // ...\n    // or call the parent to handle some events, and handle others yourself\n    DefaultEventHandler::onEvent(event);\n}\n</code></pre></p> <p>If you do not want the default behavior at all, you can remove the default event listener by using: <pre><code>MMFSConfig config = MMFSConfig()\n    .withNoDefaultEventListener();\n</code></pre> This way, only your custom listeners will process events.</p>"},{"location":"user-guide/ifaces/event/#typical-usage-example","title":"Typical Usage Example","text":"<p>Below is a simple example showing how you might create a custom event, a custom listener, and dispatch an event:</p> <pre><code>#include &lt;Event.h&gt;          // Contains IEventListener, EventManager, etc.\n#include &lt;DefaultEvents.h&gt;  // For reference to built-in events (optional)\n\nusing namespace mmfs;\n\n// 1. Define a custom event by inheriting from Event\nclass MyCustomEvent : public Event {\npublic:\n    MyCustomEvent(const char* message)\n      : Event(\"MY_CUSTOM_EVENT\"_i), msg(message) {}\n\n    const char* msg;\n};\n\n// 2. Create a listener to handle events\nclass MyListener : public IEventListener {\npublic:\n    void onEvent(const Event *e) override {\n        if (e-&gt;ID == \"MY_CUSTOM_EVENT\"_i) {\n            const MyCustomEvent* ce = static_cast&lt;const MyCustomEvent*&gt;(e);\n            // Do something with ce-&gt;msg\n        }\n        else if (e-&gt;ID == \"LOG_DATA\"_i) {\n            // Possibly handle built-in LogData event\n        }\n        // Other events...\n    }\n};\n\nvoid setup() {\n    // The MyListener constructor automatically subscribes to the event manager\n    static MyListener myListener;\n\n    // Dispatch an event\n    MyCustomEvent evt(\"Hello World!\");\n    getEventManager().invoke(evt);\n}\n\nvoid loop() {\n    // ...\n}\n</code></pre> <ol> <li><code>MyCustomEvent</code> extends <code>Event</code>, adding <code>msg</code> to store a string.  </li> <li><code>MyListener</code> overrides <code>onEvent()</code>, checking the event ID to see if it\u2019s our custom event.  </li> <li>In <code>setup()</code>, we create a <code>MyListener</code> instance (thus subscribing) and invoke an event.</li> </ol>"},{"location":"user-guide/ifaces/event/#summary","title":"Summary","text":"<ul> <li>Events allow a decoupled way of communicating changes or notifications within MMFS.  </li> <li><code>IEventListener</code> classes automatically subscribe to all events.  </li> <li>Event IDs can be manually specified or derived via the string hashing syntax <code>\"SOME_ID\"_i</code>.  </li> <li>Default events like <code>LogData</code>, <code>GPSFix</code>, and <code>BoolEvent</code> are provided for common tasks.  </li> <li><code>DefaultEventHandler</code> gives out-of-the-box functionality that you can override or remove (<code>.withNoDefaultEventListener()</code>) if you want full control.</li> <li>You can manually subscribe specific methods to the EventManager.</li> </ul> <p>By taking advantage of this flexible event system, your application can remain modular and easy to maintain, with different parts of the system responding only to the events they care about.</p> <p>Written by ChatGPT. Information may not be completely accurate.</p>"},{"location":"user-guide/ifaces/filters/","title":"Filters","text":"<p>Currently only have a 6dof Kalman filter aas an option. See the examples/Avionics folder for an example. The current system is dense and unoptimized, so is likely to change. As such, docs have not been written for it.</p>"},{"location":"user-guide/ifaces/sensor/","title":"Sensor","text":"<p>The Sensor interface is the core purpose of MMFS. It allows us to reuse code across subteams without reinventing the wheel. In the past, Avionics developed a sensor board with a GPS, Baromenter, and 9DoF IMU that all three SRAD electronics teams on the competition rocket used.</p> <p>The Sensor interface extends DataReporter, and further  breaks down into multiple different types of sensors, each with their own functionality.</p>"},{"location":"user-guide/ifaces/sensor/#main-points","title":"Main Points","text":"<ol> <li> <p><code>update()</code> and <code>begin()</code></p> <p>These two methods allow all sensors to be initialized or updated from one large loop. They internally call <code>init()</code> and <code>read()</code>. You can specify whether the sensor should use BiasCorrection or not in the <code>begin(bool useBiasCorrection)</code> method. 2. <code>init()</code> and <code>read()</code> These are designed to be hte methods that users implement to read the physical hardware sensors. In our implementation of each sensor, these two functions retrieve data from the hardware and store them  in internal variables, and the <code>update()</code> and <code>begin()</code> functions do any kind of transformations on that data that need to be done before they can be passed to the State for processing.</p> </li> </ol>"},{"location":"user-guide/ifaces/sensor/#implementation","title":"Implementation","text":"<p>There are currently 6 types of sensors:</p> <pre><code>BAROMETER_,\nGPS_,\nIMU_,\nLIGHT_SENSOR_,\nENCODER_,\nOTHER_\n</code></pre> <p>MMFS provides basic implementations of each of these, with the exception of <code>OTHER_</code>. If you have your own sensor to implement, determine first if it can fit under the umbrella of one of these types. If so, you may save yourself a lot of work. If not, you can utilize the <code>OTHER_</code> category and create your own implementation.</p> Implementing an Existing TypeCreating Your Own Type <p>First, find the source file and the related docs file for the type you with to implement.</p> <ul> <li>Barometer</li> <li>Encoder</li> <li>GPS</li> <li>IMU</li> <li>LightSensor</li> </ul> <p>Next, find a library online that interfaces with your sensor of choice. We use Adafruit and Sparkfun libraries mostly, but there are many of them out there. This makes it much easier to interface with the hardware, allowing you to focus on functionality without worrying about writing to individual registers. When you find one, great!</p> <p>Go into the docs for the type of sensor your using and see how we set them up. Essientially, you should only have to override the init() and read() methods, allowing you to quickly get up and running with your new sensor.</p> <p>Note</p> <p>As an aside, almost every sensor we use has I2C capabilities that we leverage. You may see specific code related to that, but if yours uses SPI or some other communication interface, don't worry. You can still use these pre-built interfaces.</p>"},{"location":"user-guide/ifaces/sensors/light/","title":"LightSensor","text":"<p>idk maybe</p>"},{"location":"user-guide/utils/blinkbuzz/","title":"BlinkBuzz","text":"<p>This utility is designed to be used as-is, without the end user (you) having to overload or otherwise modify it. It is an asynchronous utility for outputting patterned buzzes and LED blinks. It can be used to create simple patterns, such as beeping a certain number of times, or more complex patterns, such as SOS in morse code. It can also be used to create patterns that repeat indefinitely or patterns that repeat a specific number of times. It is designed to be easy to use and flexible enough to handle a wide variety of use cases.</p>"},{"location":"user-guide/utils/blinkbuzz/#setup","title":"Setup","text":"<p>We strongly recommend that you use the <code>MMFSSystem</code> and <code>MMFSConfig</code> objects whenever you use MMFS. That said, all utilities have the ability to be used outside of <code>MMFSSystem</code>, including BlinkBuzz. The only difference between the two is the setup. All other functions are identical.</p> With MMFSSystemWithout MMFSSystem <p>BlinkBuzz does not have too many configuration options. Here they are, shown with their default values if they have them:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nint GPS_STATUS_PIN = 25;\n\nMMFSConfig config = MMFSConfig()\n                    .withBuzzerPin(int pinNum) // no default\n                    .withBBPin(int pinNum) // add any pin you'd like, no default\n                    .withBBPin(int pinNum) // add as many pins as you want, no default\n                    .withBBAsync(true, 50); // allow async patterns, max queue size of 50.\n\nMMFSSystem system = MMFSSystem(config);\n</code></pre> <p>In <code>setup()</code> you must call <code>system.init()</code> to initialize the system. This will also initialize the BlinkBuzz utility.</p> <p>In order to take advantage of the async features, you must call <code>system.update()</code> in your <code>loop()</code>. This will also update the BlinkBuzz utility.</p> <p>If you do not wish to use the MMFSSystem, you can use BlinkBuzz as a standalone utility. You must however set up the object yourself, and remember to call <code>bb.update()</code> in your <code>loop()</code>. </p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nint *allowedPins[] = { LED_BUILTIN, 33 };\nBlinkBuzz bb; //define a global variable that is declared in the Blinkbuzz.h file for easy access across files\n\ndouble lastTime = 0; // See loop()\n\nsetup() {\n    bb.init(allowedPins, 2, true, 50); // allowed pins, number of pins, allow usage of async patterns, Max queue size per pin (async mode only)\n    //NOTE: Max queue size refers to the number of on and off toggles that are performed, so ON -&gt; OFF is 2 spots in the queue.\n}\n\nloop()\n{\n    bb.update(); // The more frequently this is called, the more accurate the timing will be.\n\n    // We recommend not using a delay() call for loop iterations when using async patterns.\n    // Instead, maybe try something like this:\n\n    double time = millis();\n    if(time - lastTime &lt; DESIRED_INTERVAL) // however much you would have otherwise delay()ed for\n        return;\n    lastTime = time; // lastTime = global variable\n\n    // the rest of your loop code here\n}\n</code></pre> <p>Warning</p> <p>There is a moderate memory overhead associated with using async patterns. Keep queue sizes as small as is reasonable.</p>"},{"location":"user-guide/utils/blinkbuzz/#usage","title":"Usage","text":"<p>In any file that includes BlinkBuzz, you can use any of the BlinkBuzz functions. </p>"},{"location":"user-guide/utils/blinkbuzz/#synchronous-usage","title":"Synchronous usage","text":"<p>These are the calls you would make while in <code>setup()</code> or if you disable async usage.</p> <p>Note</p> <p><code>BBPattern</code> arguments are not supported in synchronous function calls, nor are they planned to be in the future.</p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nvoid setup() {\n\n    // Simply hold the pin on/off:\n    bb.on(BUZZER);  // turn on\n    bb.off(BUZZER); // turn off\n\n    //Patternize\n    bb.onoff(BUZZER, 200, 3, 100); // beep 3 times, 200ms on, 100ms off\n    // OR\n    bb.onoff(BUZZER, 200, 5);      // beep 5x, 200ms on, 200ms off\n    // OR\n    bb.onoff(BUZZER, 200);         // beep 1x, 200ms on\n}\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#async-usage","title":"Async Usage","text":"<p>Asynchronous use was the reason BlinkBuzz came to be in the first place, and is what makes the utility so valuable and powerful. You can blink lights in custom patterns indefinitely, without blocking the rest of your code. This is invaluable during testing as the buzzer can beep to indicate state changes without stopping the State from updating.</p>"},{"location":"user-guide/utils/blinkbuzz/#old-school","title":"Old-School","text":"<p>Here are the most basic examples of how to use the async functions: <pre><code>    bb.aonoff(BUZZER, 200, 3, 100); // beep 3 times, 200ms on, 100ms off\n    // OR\n    bb.aonoff(BUZZER, 200, 5);      // beep 5x, 200ms on, 200ms off\n    // OR\n    bb.aonoff(BUZZER, 200);         // beep 1x, 200ms on\n\n    // Can clear a pin's queue:\n    bb.clearQueue(BUZZER);\n</code></pre></p>"},{"location":"user-guide/utils/blinkbuzz/#bbpattern","title":"BBPattern","text":"<p>You can also use the <code>BBPattern</code> class to build complex patterns. You define a pattern  with the same arguments as <code>onoff()</code>, but you can also append patterns to each other, and add \"rests\" to the end of a pattern. You may then call the pattern with <code>aonoff()</code> with any pin.</p> <pre><code>    BBPattern pattern = BBPattern(ON_DURATION, REPEATS, OFF_DURATION);\n    // For example, to build an SOS pattern, build the S and O letters:\n    BBPattern s(50, 3, 200);\n    BBPattern o(500, 3, 200);\n    // Then, append them to each other to build a single SOS pattern using the `a()` function:\n    BBPattern sos;\n    sos.a(s).a(o).a(s);\n    //NOTE: do not do BBPattern sos = s.a(o).a(s); as this will not work as expected. Minor bug.\n    // Then call it\n    bb.aonoff(BUZZER, sos);\n\n    // To repeat a pattern indefinitely, use the following:\n    bb.aonoff(BUZZER, sos, true);\n\n    // You can also append a \"rest\" to the end of a pattern, changing it's final duration.\n    bb.aonoff(BUZZER, sos.r(1000), true); // Rest for 1 second between the SOS patterns\n    //The rest can be added inline like this or to the pattern object itself.\n\n    // Appending patterns and adding rests can be done in any order as many times as you wish (so long as you have the queue space to hold them)\n}\n</code></pre>"},{"location":"user-guide/utils/circbuf/","title":"CircBuffer","text":"<p>This class is exactly what it sounds like. It uses an array based implementation of a queue to hold a buffer of any kind of object. Internally, it's used as part of the Sensor drift correction system to store data for averaging, but it can realistically be used for anything.</p>"},{"location":"user-guide/utils/circbuf/#usage","title":"Usage","text":"<p>Initialization and adding/removing: <pre><code>#include &lt;CircBuffer.h&gt;\n\n// Create a circular buffer of 10 integers\nCircBuffer&lt;int&gt; buffer(10);\n// Add an element to the buffer\nbuffer.push(1);\n// See top of the queue\nint top = buffer.peek();\n// Pop an element from the buffer\nint popped = buffer.pop();\n</code></pre></p> <p>There are also these other standard functions, that do about what you'd expect: <pre><code>bool isEmpty();\nbool isFull();\nint getSize(); // capacity of buffer\nint getCount(); // number of elements in buffer\nvoid clear();\n</code></pre></p> <p>Finally, you can use the <code>[]</code> operator to access elements. <code>buffer[0]</code> is the top of the queue, and <code>buffer[buffer.getCount() - 1]</code> is the bottom.</p>"},{"location":"user-guide/utils/logger/","title":"Logger","text":"<p>Note</p> <p>It is very likely that this class has minor changes to to the way it is set up in the future. Please verify that the website footer indicates the correct MMFS version number.</p> <p>The Logger class is one of the most powerful, but also one of the most complicated systems in MMFS. It can take both log data and flight data and write them to onboard storage or USB. It (by default) performs less frequent writes during pre- and post-flight periods to prevent writing unnecessary data. Additionally, it can modify the date of file creation so it is accurate once an onboard GPS obtains a time fix (Not currently working). Finally, if it crashes, it will log the reason for the crash the next time it boots.</p> <p>With all this functionality, there are numerous configuration options to choose from, so feel free to jump to a specific section using the table of contents on the right.</p>"},{"location":"user-guide/utils/logger/#setup","title":"Setup","text":"<p>The first thing to know about the Logger class is that it exists as a singleton, accessed via the global <code>getLogger()</code> method. Every time you need to use any of the Logger\u2019s functions, you should prefix them with <code>getLogger()</code> followed by the function call.</p> <p>We strongly recommend using the <code>MMFSSystem</code> and <code>MMFSConfig</code> objects whenever you use MMFS, as they handle almost all initialization tasks for you. However, all utilities can be used outside of <code>MMFSSystem</code>, including Logger. The only difference between these two approaches is the setup. All other functions are identical.</p> With MMFSSystemWithout MMFSSystem <p>Here is a list of the <code>MMFSConfig</code><sup>1</sup> options relevant to Logger:</p> <p>These defaults should be fine for most use cases. The defaults are shown below:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nMMFSConfig config = MMFSConfig()\n                    .withOtherDataReporters(DataReporter **others) // Add additional objects that can report flight data\n                    .withLogPrefixFormatting(\"$time - [$logType] \"); // Change format string for log data (must include $time and $logType)\n</code></pre> <p>If you simply want to use Logger without <code>MMFSSystem</code>, you need to call <code>getLogger().init()</code> with the default parameters. You must pass all the DataReporter objects (including State and all its sensors) and their count. You can also pass in the buffer time and buffer interval variables. Check if it worked with <code>getLogger().isReady()</code>. At the end of setup (after all of the data reporters are initialized), you should call <code>getLogger().writeCsvHeader()</code> to write the initial line to the SD card.</p> <pre><code>#include &lt;Logger.h&gt;\n\nsetup() {\n    // Example:\n    DataReporter *reporters[] = { &amp;state, &amp;sensor1, &amp;sensor2, ... };\n    getLogger().init(reporters, numberOfReporters, 30, 30);\n    if (getLogger().isReady()) {\n        getLogger().writeCsvHeader();\n    }\n}\n</code></pre>"},{"location":"user-guide/utils/logger/#recording-log-data","title":"Recording Log Data","text":""},{"location":"user-guide/utils/logger/#before-you-begin","title":"Before You Begin","text":"<p>All log data is recorded to a file called <code>###_Log.txt</code>, where ### is an incrementor based on files already existing in the file system (So largest # = newest file). It prefixes all log entries with a timestamp and a log type. The log types are:</p> <ul> <li><code>INFO_</code>: General system information (default).</li> <li><code>WARNING_</code>: A warning about a potential issue.</li> <li><code>ERROR_</code>: An error that has occurred.</li> <li><code>LOG_</code>: A log entry that is not an error or warning.</li> <li><code>CUSTOM_</code>: A log entry with a custom prefix.</li> </ul> <p>You can change the format of the default log types before calling <code>getLogger().init()</code> by calling:</p> <pre><code>getLogger().setLogPrefixFormatting(const char *prefix);\n</code></pre> <p>The default is <code>\"$time - [$logType] \"</code>, which will produce something like <code>0.000 - [INFO] Hello, world!</code>. When you call this function, you must include the keywords <code>$time</code> and <code>[$logType]</code>. <code>$time</code> is replaced with the time (in seconds) since the microcontroller turned on (printed with 3 decimal places), and <code>[$logType]</code> is replaced with the log type stamp. You can include any additional text you like.</p> <p>You may change the log prefix for the custom log type by calling:</p> <pre><code>getLogger().setCustomLogPrefix(const char *prefix);\n</code></pre> <p>The default is <code>\"$time - [CUSTOM] \"</code>, which would output something like <code>0.000 - [CUSTOM] Hello, world!</code>. Including <code>$time</code> is recommended but not required. This method can be called at any time, and the custom prefix will remain until overridden by a subsequent call.</p> <p>When you record log data, you can send it to the SD card, USB serial, or both. The default behavior is to record to both. These options exist in the <code>Dest</code> enum:</p> <pre><code>enum Dest {\n    TO_FILE,\n    TO_USB,\n    BOTH\n};\n</code></pre>"},{"location":"user-guide/utils/logger/#recording-data","title":"Recording Data","text":"<p>Once setup is complete, you can record log data using:</p> <pre><code>getLogger().recordLogData(...);\n</code></pre> <p>There are eight different function overloads for this method, each taking different arguments. Essentially, you specify the log type, where you want to send it (destination), and the actual data you want to log. You can optionally supply a timestamp instead of letting it be generated automatically, and you can choose to use or not use a printf-style format string followed by any number of arguments. Rather than list every overload, here are a couple of examples:</p> <pre><code>getLogger().recordLogData(WARNING_, TO_USB, \"Hello, world!\");\ngetLogger().recordLogData(INFO_, TO_FILE, 50, \"Hello %s\", \"there!\");\n</code></pre> <p>Note</p> <p>If you use the format string versions of the method, you must provide an integer representing the maximum length you expect the string to be once formatted (50 in this example).</p> <p>Once the data is logged to its destination, Logger will fire a <code>LogData</code> event with the ID <code>\"LOG_DATA\"_i</code><sup>2</sup>. You can listen for this event if you want to do something additional with the logged data.</p>"},{"location":"user-guide/utils/logger/#recording-flight-data","title":"Recording Flight Data","text":""},{"location":"user-guide/utils/logger/#before-you-begin_1","title":"Before You Begin","text":"<p>Flight data is stored in two files: a preflight data file and a flight data file. By default, it only stores pre- and post-flight data once every 30 seconds. This is why having a robust State with proper launch detection is important. By default, it also stores the most recent 30 seconds of data before launch at the full data rate. You can change this behavior by modifying the buffer time and buffer interval parameters in the init function. To write all data directly to the SD card, set the buffer interval to zero. To write no data to the SD card and store everything in PSRAM until landing is detected, set the buffer interval to less than zero.</p> <p>The Logger currently supports two types of file storage hardware. a MicroSD card, plugged into the slot on the Teensy, and QSPI NAND Flash, soldered onto the bottom of the board. The logger prefers using the flash memory for robustness reasons, but will fallback to the SD card if flash is not detected.</p> <p>All functionality surrounding flight and preflight data is managed by an internal enum called <code>Mode</code>. By default, the mode is <code>GROUND</code>. Once you call:</p> <pre><code>getLogger().setMode(FLIGHT);\n</code></pre> <p>the Logger assumes the rocket has just launched and switches into flight mode. When landing is detected, simply call:</p> <pre><code>getLogger().setMode(GROUND);\n</code></pre> <p>and the Logger will switch back to pre-/post-flight data mode.</p>"},{"location":"user-guide/utils/logger/#recording-data_1","title":"Recording Data","text":"<p>If you use the MMFSSystem objects, this is done automatically when you call <code>system.update()</code> in your loop. If you are not using the MMFSSystem objects, you must call:</p> <pre><code>getLogger().recordFlightData();\n</code></pre> <p>in your loop to record flight data. This method automatically detects the mode and logs the appropriate data. The order of columns in the CSV file is determined by the order of the data reporter objects passed to the Logger. If you use MMFSSystem, this will be the State followed by all sensors in the order they were passed to the State, then anything else added later.</p>"},{"location":"user-guide/utils/logger/#miscellaneous","title":"Miscellaneous","text":""},{"location":"user-guide/utils/logger/#changing-the-creation-date-of-files","title":"Changing the Creation Date of Files","text":"<p>Unfortunately, the SD card itself has no concept of real-world time. However, most flight systems have a GPS onboard, and by taking advantage of the default GPS event, MMFS will attempt to set correct creation and modification dates for all files on the SD card, making them easier to manage later. This is handled by default through the default event handler<sup>2</sup>. If you disabled the default event handler, you can still modify file dates by calling:</p> <pre><code>getLogger().modifyFileDates(GPS *gps);\n</code></pre>"},{"location":"user-guide/utils/logger/#crashreport","title":"CrashReport","text":"<p>This is another feature of Logger. It has no configuration options, but it is helpful to have. If the Teensy detects a crash, a crash report object is created, and the Logger will attempt to record it in the <code>###_Log.txt</code> file on the next boot.</p> <ol> <li> <p>MMFSConfig from MMFSSystem \u21a9</p> </li> <li> <p>Event \u21a9\u21a9</p> </li> </ol>"},{"location":"user-guide/utils/math/","title":"Math","text":""},{"location":"user-guide/utils/math/#matrix","title":"Matrix","text":"<p>The Matrix class is designed for use with Kalman filters. It is based on a simple array of doubles and supports most matrix operations, including addition, subtraction, multiplication, transposition, and inversion.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Dynamically allocate memory for a 3x3 matrix\ndouble* data = new double[3 * 3]{\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n};\n\nMatrix m1 = Matrix(3, 3, data);\n// Perform matrix operations here...\n</code></pre> <p>Warning</p> <p>The Matrix class takes ownership of the array passed through its constructor and only makes a shallow copy. This means that: - The array must be dynamically allocated (i.e., allocated on the heap) rather than on the stack. - You should not modify or delete the array after passing it to the Matrix constructor.</p>"},{"location":"user-guide/utils/math/#quaternion","title":"Quaternion","text":"<p>Our Quaternion class is adapted from Adafruit's <code>imu</code> namespace. It is used by the IMU to store orientation data. It supports vector operations such as addition, subtraction, and multiplication, as well as quaternion-specific operations like quaternion multiplication and conversion to/from Euler angles.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Create a quaternion with specific components (w, x, y, z)\nQuaternion q1 = Quaternion(1.0, 0.0, 0.0, 0.0);\n\n// Normalize the quaternion to ensure valid rotation data\nq1.normalize();\n\n// Convert to Euler angles (yaw, pitch, roll)\nVector&lt;3&gt; euler = q1.toEuler321();\n\n// Perform other quaternion operations here...\n</code></pre>"},{"location":"user-guide/utils/math/#vector","title":"Vector","text":"<p>The Vector class is used to represent a mathematical vector (not to be confused with the C++ <code>std::vector</code>). This Vector has a fixed length containing <code>double</code> values. It supports vector operations like addition, subtraction, multiplication, as well as dot products and cross products. It is also adapted from Adafruit's <code>imu</code> vector class.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Create two 3D vectors\nVector&lt;3&gt; v1 = Vector(1.0, 2.0, 3.0);\nVector&lt;3&gt; v2 = Vector(3.0, 2.0, 1.0);\n\n// Compute the dot product\ndouble dotVal = v1.dot(v2); // 1*3 + 2*2 + 3*1 = 3 + 4 + 3 = 10\n\n// Compute the cross product\nVector crossVal = v1.cross(v2); // (2*1 - 3*2, 3*3 - 1*1, 1*2 - 2*3)\n\n// Perform additional vector operations as needed...\n</code></pre>"},{"location":"user-guide/utils/mmfssys/","title":"MMFSSystem","text":"<p>The MMFSSystem object is designed to make interacting with the MMFS library as simple as possible. You begin by defining an MMFSConfig object, configuring all of the parameters your flight code needs, and then passing that configuration object into an MMFSSystem object. Afterward, you only need to call the <code>init()</code> and <code>update()</code> functions. MMFSSystem will take care of everything else.</p>"},{"location":"user-guide/utils/mmfssys/#mmfsconfig","title":"MMFSConfig","text":"<p>The MMFSConfig object uses a builder-like pattern, making it easy to set up MMFS. The only configuration option that you must use in order to run MMFSSystem is to pass a derived State object with proper launch detection.</p>"},{"location":"user-guide/utils/mmfssys/#code-example-withstate","title":"Code Example: <code>withState(...)</code>","text":"<pre><code>#include &lt;MMFS.h&gt;\n#include &lt;MyCustomState.h&gt; // A user-defined State class that detects launch\n\n\nMyCustomState myState;\n\nMMFSConfig config = MMFSConfig()\n                    .withState(&amp;myState); // REQUIRED\n</code></pre> <p>Where <code>myState</code> is your derived State object that handles launch detection.</p>"},{"location":"user-guide/utils/mmfssys/#mmfsconfig-options","title":"MMFSConfig Options","text":"<p>Below is a refined list of the configuration methods available in MMFSConfig. Each returns a reference to the same MMFSConfig instance, allowing you to chain calls together:</p> <ul> <li> <p><code>withState(State *state)</code>   Adds a derived State (and its associated sensors) to MMFS. This is required for MMFSSystem to function properly.</p> </li> <li> <p><code>withUpdateRate(unsigned int updateRate)</code>   Sets an update rate in Hertz. (Default is <code>10</code>.) Mutually exclusive with update interval.</p> </li> <li> <p><code>withUpdateInterval(unsigned int updateInterval)</code>   Sets the update interval in milliseconds. (Default is <code>100</code>.) Mutually exclusive with update rate.</p> </li> <li> <p><code>withSensorBiasCorrectionDataLength(unsigned int sensorBiasCorrectionDataLength)</code>   Specifies the duration (in seconds) over which sensors will average data to correct for drift. This duration is affected by the update rate/interval. (Default is <code>2</code>.)</p> </li> <li> <p><code>withSensorBiasCorrectionDataIgnore(unsigned int sensorBiasCorrectionDataIgnore)</code>   Specifies the duration (in seconds) of the most recent data to ignore when performing drift correction. This duration is also affected by the update rate/interval. (Default is <code>1</code>.)</p> </li> <li> <p><code>withUsingSensorBiasCorrection(bool useBiasCorrection)</code>   Determines whether sensors will continuously re-zero themselves while on the ground. (Default is <code>false</code>.) Warning: This function requires working launch detection or data may not be accurate.</p> </li> <li> <p><code>withBuzzerPin(unsigned int buzzerPin)</code>   Sets the named <code>BUZZER</code> for use with <code>BlinkBuzz</code>. (No Default.)</p> </li> <li> <p><code>withBBPin(unsigned int bbPin)</code>   Adds a pin to <code>BlinkBuzz</code>. By default, no pins are added.</p> </li> <li> <p><code>withBBAsync(bool bbAsync, unsigned int queueSize = 50)</code>   Allows <code>BlinkBuzz</code> to use asynchronous features. This incurs moderate memory overhead based on the queue size (the number of state changes a pin can queue). (Default is <code>true</code> and <code>50</code>.)</p> </li> <li> <p><code>withReducedPreFlightDataRate(bool useReducedRate, unsigned int secondsBetweenRecords)</code>   Enables or disables reduced data rates before flight. (Default is <code>true</code>, <code>30</code> seconds.) Warning: This requires working launch detection or all data will remain at the reduced rate.</p> </li> <li> <p><code>withOtherDataReporters(DataReporter **others)</code>   Adds additional DataReporter objects for flight data logging. Passing a State via <code>withState()</code> automatically captures that State\u2019s sensors, so adding them here might be redundant.</p> </li> <li> <p><code>withNoDefaultEventListener()</code>   Removes the default event handler from the event manager, useful if you have a custom one that alters default behavior.</p> </li> <li> <p><code>withLogPrefixFormatting(const char *prefix)</code>   Changes the formatting of the log prefix. You must use <code>$time</code> and <code>$logType</code> to reference the current log\u2019s time and log type. (Default is <code>\"$time - [$logType] \"</code>.)</p> </li> </ul>"},{"location":"user-guide/utils/mmfssys/#full-example","title":"Full Example","text":"<p>Below is a simple, hypothetical Arduino sketch illustrating how to use MMFSSystem with MMFSConfig:</p> <p><pre><code>#include &lt;Arduino.h&gt;\n#include &lt;MMFS.h&gt;\n#include &lt;MyCustomState.h&gt;  // Your derived State class\n#include &lt;MyCustomReporter.h&gt; // Additional DataReporter\n\n// Create instances\nMyCustomState myState;\nMyCustomReporter myReporter;\n\n// Create the configuration\nMMFSConfig config = MMFSConfig()\n    .withState(&amp;myState)    // Required for launch detection\n    .withUpdateRate(20)     // 20 Hz update\n    .withOtherDataReporters({&amp;myReporter}) // Additional data reporters\n    .withLogPrefixFormatting(\"$time - [$logType]: \");\n\n// Create the system object\nMMFSSystem system = MMFSSystem(config);\n\nvoid setup() {\n    Serial.begin(115200);\n    // Initialize the system\n    system.init(); // (1)!\n}\n\nvoid loop() {\n    // Update the system\n    system.update();\n\n    // Your other code goes here...\n}\n</code></pre></p> <ol> <li>This function will call events based on whether or not State and Logger initialize successfully. They are automatically handled by the default event listener.</li> </ol>"},{"location":"user-guide/utils/test/","title":"Test page","text":""}]}