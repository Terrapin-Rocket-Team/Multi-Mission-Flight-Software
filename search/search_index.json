{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This page written by ChatGPT. May not be accurate or helpful.</p>"},{"location":"#welcome-to-the-terrapin-rocket-teams-multi-mission-flight-software-mmfs-documentation","title":"Welcome to the Terrapin Rocket Team's Multi-Mission Flight Software (MMFS) Documentation","text":"<p>Welcome to the (maybe) official documentation site for TRT's Multi-Mission Flight Software (MMFS)\u2014the versatile and robust flight code framework developed by the Terrapin Rocket Team (TRT). Whether you're looking to integrate MMFS into your next mission, contribute to its ongoing development, or explore its unique capabilities, you've come to the right place!</p>"},{"location":"#what-is-mmfs","title":"\ud83d\ude80 What is MMFS?","text":"<p>MMFS is a modular and scalable flight software framework designed to meet the diverse needs of rocketry missions. Built with adaptability and reliability in mind, it provides a solid foundation for developing and deploying mission-critical systems. </p>"},{"location":"#explore-the-docs","title":"\ud83d\udcda Explore the Docs","text":"<p>This documentation is organized into three main sections to help you navigate the MMFS ecosystem:</p>"},{"location":"#1-getting-started","title":"1. Getting Started","text":"<ul> <li>Learn how to install MMFS and set it up as your base flight code framework.</li> <li>Step-by-step guides for configuring MMFS to meet your mission's requirements.</li> <li>Code snippets and examples to help you hit the ground running.</li> </ul>"},{"location":"#2-maintaining-mmfs","title":"2. Maintaining MMFS","text":"<ul> <li>Dive into the internals of MMFS to understand its architecture and core principles.</li> <li>Learn best practices for maintaining and updating the library.</li> <li>Contribution guidelines for those looking to improve MMFS.</li> </ul>"},{"location":"#3-miscellaneous-resources","title":"3. Miscellaneous Resources","text":"<ul> <li>Additional tools and utilities to enhance your development experience.</li> <li>Tips, tricks, and advanced usage scenarios.</li> <li>Frequently asked questions and troubleshooting.</li> </ul>"},{"location":"#features-at-a-glance","title":"\u2728 Features at a Glance","text":"<ul> <li>Modularity: Pick and choose components to fit your mission's needs.</li> <li>Scalability: From single-stage to multi-stage rockets, MMFS grows with your ambitions.</li> <li>Open Source: Join a community of rocketry enthusiasts and contribute to the future of MMFS.</li> </ul>"},{"location":"#ready-to-start","title":"\ud83c\udf1f Ready to Start?","text":"<p>Head over to the Getting Started section to begin your journey with MMFS. If you're a seasoned developer or contributor, check out the Maintaining MMFS section to dive deeper into the framework.</p> <p>Together, let's push the boundaries of rocketry innovation!</p>"},{"location":"maintainer-guide/","title":"Internal MMFS Maintenance Documentation","text":"<p>This section not yet completed.</p>"},{"location":"maintainer-guide/#maintaining-these-docs","title":"Maintaining these docs","text":"<ol> <li>die</li> <li>don't die</li> <li>??</li> <li>\\$$</li> </ol>"},{"location":"user-guide/basic-use/","title":"Basic Usage","text":"<p>Important!</p> <p>In order for PIO to recognize that you are working on a PIO project, you must open VSCode in the root directory of that project. that is, the directory that has the <code>platformio.ini</code> file in it. Without this, PlatformIO will not initialize and you will be unable to build or use proper Intellisense.</p>"},{"location":"user-guide/basic-use/#intro","title":"Intro","text":"<p>There are very few things that need to be done in order for the absolute minimum requirements to use MMFS to be met. You must: Extend the <code>State</code> class, pass it to an <code>MMFSSystem</code> object, and call the <code>init</code> and <code>update</code> methods during setup and loop, respectively. There are, of course, many more things that you can do to tailor MMFS to your preferences, but we'll start slow.</p>"},{"location":"user-guide/basic-use/#initial-integration","title":"Initial Integration","text":""},{"location":"user-guide/basic-use/#overriding-state","title":"Overriding <code>State</code>","text":"<p>Let's start by extending <code>State</code>. In your <code>src</code> folder, make a new set of files called something like <code>NewState.h</code> and <code>NewState.cpp</code>.</p> <p>Paste these contents into them:</p> NewState.hNewState.cpp <pre><code>#ifndef NEWSTATE_H\n#define NEWSTATE_H\n\n#include &lt;State/State.h&gt;\n\nusing namespace mmfs;\nclass NewState : public State {\n    public:\n        NewState(Sensor **sensors, int numSensors, Filter *filter);\n        void determineStage() override;\n};\n\n#endif\n</code></pre> <p><pre><code>#include \"NewState.h\"\n\nNewState::NewState(Sensor **sensors, int numSensors, Filter *filter) : State(sensors, numSensors, filter) {}\n\nvoid NewState::determineStage() // (1)!\n{\n    // Add whatever stage determination logic you'd like here.\n    // Here is one simplified example:\n    if (stage == 0 &amp;&amp; acceleration.z() &gt; 10 &amp;&amp; position.z() &gt; 20) \n    {                                                             // accelerating upwards and off the pad\n        stage = 1;                                                // ascent\n        getLogger().setRecordMode(FLIGHT);\n    }                                                             \n    else if (stage == 1 &amp;&amp; velocity.z() &lt; 0)                      // descending\n        stage = 2;                                                \n    else if (stage == 2 &amp;&amp; position.z() &lt; 20)                     \n    {                                                             // landed\n        stage = 3;\n        getLogger().setRecordMode(GROUND);\n    }\n}\n</code></pre></p> <ol> <li>You may have as many stages as you like, but MMFS expects you to have at least launch and land stages.</li> </ol> <p>Let's briefly talk about what we've done. <code>State</code> declares a method called <code>void determineStage()</code> that is called every time it updates. Only MMFS doesn't know which stages you might care about, so you have to tell it by overriding that function. The reason it's so important to detect launch and landing is because of those calls to <code>getLogger().setRecordMode()</code>. This changes the rate at which MMFS records data, but don't worry, we'll get to all of that. Just understand that this is an important method that must make those calls to <code>getLogger()</code> in order for data logging to work the way you want it to.<sup>1</sup></p>"},{"location":"user-guide/basic-use/#instantiating-the-state-object","title":"Instantiating the <code>State</code> object","text":"<p>Now that we have our <code>State</code> object with its <code>determineStage</code> method, we can head back over to the main file to finish our integration. We need to create an actual instance of the object for us to use in the <code>setup</code> and <code>loop</code> methods. You'll notice that in the constructor we implemented, it took a <code>Sensor **</code>. If you're not all that familiar with pointers, this is basically saying \"an array of pointers to <code>Sensor</code> objects\". This is because we need to pass in all of the sensors that we want to use. For now, let's just use the included 'IMU', 'GPS', and 'Barometer' sensors. We can do this by creating an array of pointers to <code>Sensor</code> objects, and then passing that to the <code>State</code> constructor. There was another important parameter, the <code>Filter</code>, which is a class that we haven't talked about yet. For now, we can just pass in <code>nullptr</code> for that parameter, as we don't need to use it right now.</p> main.cpp<pre><code>#include &lt;Arduino.h&gt;\n#include \"MMFS.h\"\n#include \"NewState.h\"\n\nMAX_M10S gps;\nDPS310 baro;\nBMI088andLIS3MDL imu9dof;\n\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nvoid setup()\n{\n\n}\n\nvoid loop()\n{\n\n}\n</code></pre> <p>Here we've used the sensors that come on the Avionics' sub-team's Sensor Board v1.1, which anyone else on the team is also welcome to use. If you need to implement your own sensors, you can check out the Sensor documentation for more information.</p>"},{"location":"user-guide/basic-use/#creating-an-mmfsconfig-object","title":"Creating an <code>MMFSConfig</code> object","text":"<p>Now, we need to create an <code>MMFSConfig</code> object, which is a neat little object that follows what's called a \"builder pattern\". This means that we can set all of the configuration options that we want, while leaving out the options we don't care about. For our use case, the only thing we need to send it is the state object, but we'll set up a couple other things as well so you get an idea of the object's versatility. Here's what that looks like:</p> main.cpp<pre><code>...\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nvoid setup()\n{\n...\n</code></pre> <p>So here, we're just setting the buzzer pin to 13 and the built-in LED pin to <code>LED_BUILTIN</code>, which is a constant that is defined in the Arduino framework. You can set any of the configuration options that you want by appending their methods to the end of the list, but for now, we'll just leave it at that. See the MMFSConfig documentation for more information.</p>"},{"location":"user-guide/basic-use/#creating-an-mmfssystem-object","title":"Creating an <code>MMFSSystem</code> object","text":"<p>Now that we have our config, we need ot actually create the <code>MMFSSystem</code> object. This is a simple one-liner:</p> main.cpp<pre><code>...\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nMMFSSystem system(config);\n\nvoid setup()\n{\n...\n</code></pre>"},{"location":"user-guide/basic-use/#calling-init-and-update","title":"Calling <code>init</code> and <code>update</code>","text":"<p>Now, we just need to call the <code>init</code> and <code>update</code> methods in the <code>setup</code> and <code>loop</code> methods, respectively. MMFS will take care of everything else. Yes, really. This is all the code you need to write to get a minimum working system up and running. </p> New codeFull main.cpp main.cpp<pre><code>MMFSSystem computer = MMFSSystem(&amp;config);\n\nvoid setup()\n{\n  computer.init();\n}\n\nvoid loop()\n{\n  computer.update();\n}\n</code></pre> <pre><code>#include &lt;Arduino.h&gt;\n#include \"MMFS.h\"\n#include \"NewState.h\"\n\nMAX_M10S gps;\nDPS310 baro;\nBMI088andLIS3MDL imu9dof;\n\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nMMFSSystem computer = MMFSSystem(&amp;config);\n\nvoid setup()\n{\n  computer.init();\n}\n\nvoid loop()\n{\n  computer.update();\n}\n</code></pre>"},{"location":"user-guide/basic-use/#conclusion","title":"Conclusion","text":"<p>That's it! You now have a fully functional MMFS system that is ready to be used. You can add more sensors, change the configuration options, and customize the <code>NewState</code> class to your heart's content. See the MMFSConfig documentation for more information on what you can do with the config object, and see the State documentation for more information on how to customize the state object.</p>"},{"location":"user-guide/basic-use/#easy-modifications","title":"Easy Modifications","text":"<p>Here are few easy modifications that you can make to the system to make it more suited to your needs. If you don't see what you're looking for here, try the page relating to that specific feature, or reach out to someone on Avionics.</p>"},{"location":"user-guide/basic-use/#modifying-the-update-rate","title":"Modifying the update rate","text":"<p>You can modify the update rate of the system by using one of two methods on the MMFS Config object. They both have the same effect, and the last one called is the one used.</p> withUpdateRate()withUpdateInterval() <pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUpdateRate(10); // 10Hz (100 ms between updates)\n</code></pre> <pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUpdateInterval(100); // 100ms between updates (10Hz)\n</code></pre> <p>Note</p> <p>10 hz is the default rate. If you set it too high, the system may struggle to keep up, so we recommend keeping it at 50 hz or lower.</p>"},{"location":"user-guide/basic-use/#sensor-drift-correction","title":"Sensor drift correction","text":"<p>While on the pad waiting for launch, it is very likely that the sensors will begin to drift slightly. There is a feature in MMFS that allows you to correct for this until launch is detected. This correction acts by averaging out some length of sensor data, while ignoring the very most recent data. As most launch detection systems require the rocket to be noticeably off the ground and may take a few iterations to properly detect launch, the idea behind this was to stop early launch data from affecting the zeroing of the sensors.</p> <p>Danger</p> <p>Using this feature requires that you have working launch detection. If not, they will continuously attempt to correct themselves to zero, and thus report faulty data for the duration of the flight.</p> <p><pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUsingSensorBiasCorrection(true); // (1)!\n                        .withSensorBiasCorrectionDataLength(2); // two seconds of data to average over, BUT\n                        .withSensorBiasCorrectionIgnore(1); // ignore the most recent 1 second of data.\n</code></pre></p> <ol> <li>This is false by default, however the length of collection and ignoring default to the two values below, meaning you do not have to call the methods if these values are fine for you.</li> </ol>"},{"location":"user-guide/basic-use/#using-blinkbuzz","title":"Using BlinkBuzz","text":"<p>As we saw earlier, you must add the signaling pins you want to use to the <code>MMFSConfig</code> object. This is done by calling the <code>withBuzzerPin()</code> and <code>withBBPin()</code> methods. The buzzer pin is special and has some default events that utilize it. <code>withBBPin()</code> can be use to add any pin (or a second buzzer). You can add up to 50 pins.</p> <p>To use a pin, you can call <code>bb.onoff(int pin, int duration, int repeat = 1, int pause = duration)</code>. If you are in the <code>loop</code> phase of the program, you can use <code>bb.aonoff(...)</code> to do the same thing asynchronously (i.e. beep for long periods without blocking other code execution).</p> <p>See the BlinkBuzz documentation for more usage information.</p>"},{"location":"user-guide/basic-use/#using-the-logger","title":"Using the Logger","text":"<p>You can modify the format of the event logger by using the <code>withLogPrefixFormatting()</code> method. This takes a string that must include the <code>$time</code> and <code>$logType</code> (case specific) keywords. It will then format all log entries accordingly. The default is </p> <p><code>\"$time - [$logType] \"</code></p> <p>To use the logger to record data, you can call <code>getLogger().recordLogData(LogType type, const char *format, ...)</code>. This will log the data to both the SD card and USB serial port.</p> <p>See the Logger documentation for more information.</p>"},{"location":"user-guide/basic-use/#conclusion_1","title":"Conclusion","text":"<p>This just scratches the surface of what these utilities and systems can handle (blink buzz can do infinite asynchronous morse code! ...if you need that).</p> <p>See the MMFSConfig documentation for more information on what you can do with the config object.</p> <p>See the State documentation for more information on how to customize the state object.</p> <p>Also check out the Event system, Sensor interface, DataReporter interface, and Filter interface for more information on how to use some more advanced parts of the system.</p> <ol> <li> <p>There are other configuration options that you can use to disregard the stage system, but we don't recommend it. Check out the Logger documentation for more information.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/faq/","title":"Frequently Asked Questions","text":"<p>Ask Drew or Michael on Slack :(</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>You may skip over this installation step if you are working in a repo that already uses MMFS and you are just looking to get introduced.</p> <p>Important!</p> <p>In order for PIO to recognize that you are working on a PIO project, you must open VSCode in the root directory of that project. that is, the directory that has the <code>platformio.ini</code> file in it. Without this, PlatformIO will not initialize and you will be unable to build or use proper Intellisense.</p>"},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following:</p> <ul> <li>Basic knowledge of C++ programming. (knowledge of what a pointer is and how to use one)</li> <li>VSCode and the PlatformIO (PIO) extension installed. [Installation Guide]</li> <li>Basic knowledge of VSCode and the PlatformIO interface [Interface cheat-sheet]</li> <li>Basic knowledge of Git and GitHub. [TRT Git/Github Guide]</li> <li>Access to a Teensy 4.1. </li> </ul>"},{"location":"user-guide/installation/#installation","title":"Installation","text":""},{"location":"user-guide/installation/#create-a-new-platformio-project","title":"Create a new PlatformIO project","text":"<p>Pick any folder to create it in, and create a new project. We strongly recommend choosing the arduino framework and the Teensy 4.1 board, as MMFS has not been tested on any other system.</p>"},{"location":"user-guide/installation/#modify-the-platformioini-file","title":"Modify the <code>platformio.ini</code> file","text":"<p>Add a dependency to MMFS by adding the highlighted lines to your <code>platformio.ini</code> file, found in your project's root directory. <pre><code>[env:teensy41]\nplatform = teensy\nboard = teensy41\nframework = arduino\nlib_deps =\n    https://github.com/Terrapin-Rocket-Team/Multi-Mission-Flight-Software.git#v3.0.0\n</code></pre></p> <p>Info</p> <p>You may add multiple dependencies by appending new indented lines under <code>lib_deps</code>.</p> <p>Tip</p> <p>We recommend always attaching the version specifier to the end of the url, as MMFS undergoes frequent breaking changes. For github links, this looks like <code>#{tag}</code>. We give our releases (a.k.a. tags) semantic versioning<sup>1</sup> numbers like <code>v3.0.0</code></p> <p>Now save the file. You should notice PIO start to download MMFS and all of its dependencies. It may take a few minutes.</p>"},{"location":"user-guide/installation/#add-mmfsh-to-maincpp","title":"Add <code>MMFS.h</code> to <code>main.cpp</code>","text":"<p>Looking at the folder structure, PIO should have created a <code>src</code> folder with a <code>main.cpp</code> in it. It has some basic example functions that you may ignore or delete. To link MMFS to this main file though, we need to <code>#include</code> it:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;MMFS.h&gt;\n\n// put function declarations here:\nint myFunction(int, int);\n</code></pre>"},{"location":"user-guide/installation/#build-the-project","title":"Build the project","text":"<p>The last thing to do to make sure that everything went well is to simply build the project.</p> <p>You can use any of PIO's <code>build</code> buttons to achieve this. If you don't know where the buttons are, we recommend using the toolbar on the bottom of the screen, where the <code>build</code> command is represented by the checkmark.</p> <p>The terminal should spit out <code>========[SUCCESS] Took ##.## seconds=======</code>. If not, first try and see if you can understand the error. If you get stuck, please feel free to message any of the club members with experience working in PlatformIO or MMFS.</p>"},{"location":"user-guide/installation/#conclusion","title":"Conclusion","text":"<p>That's all there is to installing the library. You're now ready to move on to using it! Hopefully that part will be just as straightforward.</p> <ol> <li> <p>We always use this format, but we don't always follow correct semantic versioning procedures.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/intro/","title":"The Complete MMFS User's Manual","text":"<p>Info</p> <p>These docs were written in the order shown on the sidebar. You many notice that later docs somewhat rely on the reader understanding topics covered earlier. They should mostly be self-sufficient, but it's not guaranteed.</p> <p>As always, if you have any questions, feel free to reach out on Slack or Github.</p> <p><sub><sup><sub><sup>Now on a cool new website!</sup></sub></sup></sub></p> <p>This is the official user's manual for TRT's Multi-Mission Flight Software (MMFS). It is designed to be a comprehensive guide for users of all levels, from beginners to advanced developers. The manual covers everything from installation and setup to advanced features and troubleshooting.</p> <p>The library is essentially split into two categories: Utilities and Interfaces. </p>"},{"location":"user-guide/intro/#utilities","title":"Utilities","text":"<p>We describe utilities as any part of the library designed to be used as-is, without the end user (you) having to overload or otherwise modify it. The utilities offered by MMFS are:</p>"},{"location":"user-guide/intro/#blinkbuzz","title":"BlinkBuzz","text":"<p>An (asynchronous!) utility for outputting patterned buzzes and LED blinks.</p>"},{"location":"user-guide/intro/#circbuffer","title":"CircBuffer","text":"<p>A queue or FIFO system for storing data in a fixed-size buffer.</p>"},{"location":"user-guide/intro/#logger","title":"Logger","text":"<p>A simple logging utility that can log to the SD card or USB serial port.</p>"},{"location":"user-guide/intro/#retrievedata","title":"RetrieveData","text":"<p>A system that allows transfer of flight data files over Serial, allowing retrieval of files stored in onboard flash.</p>"},{"location":"user-guide/intro/#math","title":"Math","text":"<p>A collection of ... math? ... objects (vectors, matrices, and quaternions) and their functions.</p>"},{"location":"user-guide/intro/#mmfssystem","title":"MMFSSystem","text":"<p>An object designed to handle all of the MMFS functions during flight.</p> <p>Most of the power that MMFS offers comes from the Logger and MMFSSystem utilities. That is to say, those are two of the most complicated systems in the library.</p>"},{"location":"user-guide/intro/#interfaces","title":"Interfaces","text":"<p>Interfaces are for any other part of the library that is not fully implemented, or otherwise is expected to be modified by the end user. Most of them are not strictly interfaces, but rather abstract classes. The following interfaces are offered by MMFS:</p>"},{"location":"user-guide/intro/#state","title":"State","text":"<p>This is the main purpose of using MMFS. It is an abstract class that is used to define the state of the rocket. It is designed to be overloaded by the end user, and is used to define the behavior of the telemetry systems during flight.</p>"},{"location":"user-guide/intro/#datareporter","title":"DataReporter","text":"<p>This is an interface for recording flight CSV data using Logger. State implements it, as do all of the sensors. You may extend it to add your own data reporters.</p>"},{"location":"user-guide/intro/#sensor","title":"Sensor","text":"<p>This is the base sensor interface. There are further interfaces for each type of sensor:</p> <ul> <li>Barometer</li> <li>IMU (9DOF, including accelerometer, gyroscope, and magnetometer)</li> <li>GPS</li> <li>Encoder (a motor encoder)</li> <li>LightSensor</li> </ul>"},{"location":"user-guide/intro/#event","title":"Event","text":"<p>This is a simple, readily-extendable event system. You can create classes that listen to and fire off custom events, or overload the handler for the default events.</p>"},{"location":"user-guide/intro/#filters","title":"Filters","text":"<p>This is a basic Kalman filter interface, able to be passed into State for it to use to filter sensor data.</p>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":"<p>idk ask Drew or Michael on Slack :(</p>"},{"location":"user-guide/ifaces/data-reporter/","title":"DataReporter","text":"<p>The DataReporter class is used by the Logger system in MMFS to log flight data from various sources. Each data reporter defines the variables to be recorded, the variable types, and the labels that appear in the output CSV file. This allows you to separate your flight data into multiple, self-contained objects that easily integrate with MMFS.</p>"},{"location":"user-guide/ifaces/data-reporter/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Column Definition    In your DataReporter subclass or instance, you\u2019ll define columns inside its constructor. You specify:</p> <ul> <li>The variable to record (by passing a pointer to it).</li> <li>The type of that variable (through the <code>PackedType</code> enum).</li> <li>The label to appear in the CSV header.</li> </ul> </li> <li> <p>Name and Uniqueness DataReporter objects can be given names in their constructors. If you do not specify a name, a unique one will be assigned using a static counter.</p> </li> <li> <p>Removal of Unneeded Columns    If you extend another DataReporter but want to remove one of its default columns, you can call <code>removeColumn(...)</code> in your subclass constructor or elsewhere.</p> </li> <li> <p>Auto-Packing     Data reporters will automatically package the data, but they do not come with an update step. You must write your own update step to update the data.</p> </li> </ol>"},{"location":"user-guide/ifaces/data-reporter/#usage-overview","title":"Usage Overview","text":"<p>Below is an example of how to create and use a custom DataReporter:</p> <p><pre><code>#include &lt;DataReporter.h&gt;\n\nusing namespace mmfs;\n\nclass MyCustomReporter : public DataReporter {\npublic:\n    // Constructor with an optional name\n    MyCustomReporter(const char* name = \"MyReporter\") \n        : DataReporter(name) \n    {\n        // Example variables to record\n        int altitude;        // You'd likely store this somewhere else in real code\n        float velocity;\n        double latitude; \n\n        // In the constructor, define the columns you want logged:\n        // addColumn(PackedType, pointerToVar, \"Label in CSV\")\n        addColumn(INT, &amp;altitude, \"Altitude\");\n        addColumn(FLOAT, &amp;velocity, \"Velocity\");\n        addColumn(DOUBLE_HP, &amp;latitude, \"Latitude\"); // (1)!\n    }\n\n    // Add your own update step here to modify the data.\n};\n</code></pre></p> <ol> <li>Use <code>DOUBLE</code> for 3 decimal point precision, or <code>DOUBLE_HP</code> if you want 7 points of precision. In this example, 3 decimal points of latitude is only accurate to about 100 meters, so we record all 7 for better location precision.</li> </ol>"},{"location":"user-guide/ifaces/data-reporter/#adding-columns","title":"Adding Columns","text":"<p>To add columns, call <code>addColumn()</code> or <code>insertColumn()</code> in your DataReporter constructor (or initialization method):</p> <ul> <li> <p><code>addColumn(PackedType t, T* variable, const char* label)</code>   Appends a new column with the given type, pointer to a variable, and the label that appears in the CSV header.  </p> </li> <li> <p><code>insertColumn(uint8_t place, PackedType t, T* variable, const char* label)</code>   Inserts a new column at a specific index.</p> </li> </ul>"},{"location":"user-guide/ifaces/data-reporter/#removing-columns","title":"Removing Columns","text":"<p>If you inherit from another DataReporter but do not want one of its columns, call:</p> <pre><code>removeColumn(\"UnwantedColumnLabel\");\n</code></pre> <p>This removes the column with label <code>\"UnwantedColumnLabel\"</code> from your final data set.</p>"},{"location":"user-guide/ifaces/data-reporter/#default-behavior","title":"Default Behavior","text":"<ul> <li>When you create a DataReporter without a name, it automatically assigns a unique name based on a static counter.</li> </ul>"},{"location":"user-guide/ifaces/data-reporter/#step-by-step-example","title":"Step-by-Step Example","text":"<p>Here\u2019s a simple step-by-step guide for beginners:</p> <ol> <li> <p>Create a custom reporter    Derive a new class from DataReporter. In your constructor, add the columns you want to record, with pointers to the variables that hold that data.</p> </li> <li> <p>Register it with MMFS    Pass your DataReporter object to the <code>MMFSConfig</code> object (via <code>withOtherDataReporters(...)</code>) or manually to the Logger if you\u2019re using a standalone approach.</p> </li> <li> <p>Let MMFS manage updates    Whenever <code>MMFSSystem::update()</code> (or an equivalent mechanism) is called, your reporter\u2019s most recent data is automatically logged as a CSV row. Keep in mind that MMFS and DataReporter do not update the data stored in those variables.</p> </li> <li> <p>Check CSV output    After a flight (or test run), retrieve the <code>.csv</code> file and confirm your new columns (Altitude, Velocity, etc.) appear as expected with the correct data.</p> </li> </ol>"},{"location":"user-guide/ifaces/data-reporter/#summary","title":"Summary","text":"<ul> <li>DataReporter objects act as modular data sources for logging in MMFS.</li> <li>You specify a name, define columns for logging, and let MMFS handle how and when the data is stored or transmitted.</li> </ul> <p>Use this class to easily add flight data logging to your project, keeping your code organized and your flight logs detailed.</p> <p>Written by ChatGPT. Information may not be completely accurate.</p>"},{"location":"user-guide/ifaces/event/","title":"Events","text":"<p>Events in MMFS allow you to respond to system-wide actions or notifications. By default, these events are used to coordinate various parts of the library (e.g., logging, GPS, state changes). You can also create your own events or custom listeners to handle specific needs.</p>"},{"location":"user-guide/ifaces/event/#core-components","title":"Core Components","text":"<ol> <li> <p><code>Event</code>     A simple class carrying an EventID. Developers can create new event types by inheriting from <code>Event</code> and adding any additional data they want to share with listeners.</p> </li> <li> <p><code>IEventListener</code>     An interface that you can inherit from to automatically subscribe to all events in MMFS. Each <code>IEventListener</code> must implement:     <pre><code>void onEvent(const Event *e) override;\n</code></pre>     Inside this function, you decide how to handle any event passed to you.</p> </li> <li> <p><code>EventManager</code>     The main system responsible for event dispatch. It tracks all active <code>IEventListener</code> objects and calls their <code>onEvent()</code> methods whenever an event is invoked.</p> </li> </ol>"},{"location":"user-guide/ifaces/event/#how-it-works","title":"How It Works","text":"<ol> <li>Event Creation     An event in MMFS has a unique numeric ID. You can either:<ul> <li>Directly specify an integer ID, or</li> <li>Use the handy compile-time hashing of a string literal with <code>\"SOME_TEXT\"_i</code>.</li> </ul> </li> </ol> <p>For instance:    <pre><code>// Produces a unique integer ID at compile time\nstatic const EventID MY_CUSTOM_EVENT = \"MY_CUSTOM_EVENT\"_i;\n</code></pre></p> <ol> <li>Subscribing to Events    Whenever you create a class that inherits from <code>IEventListener</code>, its constructor automatically subscribes you to the global event manager. You do not need to manually register anything, unless you want to manually manage subscription/unsubscription.</li> </ol> <p>You may also manually subscribe/unsubscribe specific global functions (not class methods) by calling</p> <pre><code>getEventManager().subscribe(funcName);\n</code></pre> <ol> <li> <p>Dispatching Events    Any code can invoke an event by calling:    <pre><code>getEventManager().invoke(yourEventObject);\n</code></pre>    All active <code>IEventListener</code> objects will receive this event through their <code>onEvent()</code> method.</p> </li> <li> <p>Handling Events    Since every listener hears every event, you typically use an <code>if</code> or <code>switch</code> statement based on the event\u2019s ID, or perform a dynamic cast if you\u2019re dealing with a custom event type. For example:    <pre><code>void onEvent(const Event *e) override {\n    switch (e-&gt;ID) {\n        case \"LOG_DATA\"_i:\n            // Handle log data event\n            break;\n\n        case \"GPS_FIX\"_i:\n            // Handle GPS fix event\n            break;\n\n        default:\n            // Ignore or handle other events\n            break;\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"user-guide/ifaces/event/#default-events","title":"Default Events","text":"<p>MMFS provides a few built-in events for common scenarios:</p> <ul> <li> <p><code>GPSFix</code>   Notifies listeners when a GPS fix occurs or changes. It carries a pointer to the <code>GPS</code> object and a boolean indicating if this is the first time a fix has been acquired since boot.</p> </li> <li> <p><code>LogData</code>   Fired when new log data is recorded. Carries information about the log destination (<code>SD</code> vs. <code>USB</code>), the log type (e.g., <code>INFO_</code>, <code>ERROR_</code>), and the actual string message.</p> </li> <li> <p><code>BoolEvent</code>   A simple true/false style event used for various system checks (e.g., initialization success).</p> </li> </ul>"},{"location":"user-guide/ifaces/event/#default-event-handler","title":"Default Event Handler","text":"<p><code>DefaultEventHandler</code> is a built-in class that inherits from <code>IEventListener</code> and implements <code>onEvent()</code>. It provides out-of-the-box handling for:</p> <ul> <li>GPS fixes</li> <li>Log data notifications</li> <li>Initialization events</li> </ul> <p>If you need to change how these events are processed, you can subclass <code>DefaultEventHandler</code> and override its methods: <pre><code>void onEvent(const Event *event) override {\n    // ...\n    // or call the parent to handle some events, and handle others yourself\n    DefaultEventHandler::onEvent(event);\n}\n</code></pre></p> <p>If you do not want the default behavior at all, you can remove the default event listener by using: <pre><code>MMFSConfig config = MMFSConfig()\n    .withNoDefaultEventListener();\n</code></pre> This way, only your custom listeners will process events.</p>"},{"location":"user-guide/ifaces/event/#typical-usage-example","title":"Typical Usage Example","text":"<p>Below is a simple example showing how you might create a custom event, a custom listener, and dispatch an event:</p> <pre><code>#include &lt;Event.h&gt;          // Contains IEventListener, EventManager, etc.\n#include &lt;DefaultEvents.h&gt;  // For reference to built-in events (optional)\n\nusing namespace mmfs;\n\n// 1. Define a custom event by inheriting from Event\nclass MyCustomEvent : public Event {\npublic:\n    MyCustomEvent(const char* message)\n      : Event(\"MY_CUSTOM_EVENT\"_i), msg(message) {}\n\n    const char* msg;\n};\n\n// 2. Create a listener to handle events\nclass MyListener : public IEventListener {\npublic:\n    void onEvent(const Event *e) override {\n        if (e-&gt;ID == \"MY_CUSTOM_EVENT\"_i) {\n            const MyCustomEvent* ce = static_cast&lt;const MyCustomEvent*&gt;(e);\n            // Do something with ce-&gt;msg\n        }\n        else if (e-&gt;ID == \"LOG_DATA\"_i) {\n            // Possibly handle built-in LogData event\n        }\n        // Other events...\n    }\n};\n\nvoid setup() {\n    // The MyListener constructor automatically subscribes to the event manager\n    static MyListener myListener;\n\n    // Dispatch an event\n    MyCustomEvent evt(\"Hello World!\");\n    getEventManager().invoke(evt);\n}\n\nvoid loop() {\n    // ...\n}\n</code></pre> <ol> <li><code>MyCustomEvent</code> extends <code>Event</code>, adding <code>msg</code> to store a string.  </li> <li><code>MyListener</code> overrides <code>onEvent()</code>, checking the event ID to see if it\u2019s our custom event.  </li> <li>In <code>setup()</code>, we create a <code>MyListener</code> instance (thus subscribing) and invoke an event.</li> </ol>"},{"location":"user-guide/ifaces/event/#summary","title":"Summary","text":"<ul> <li>Events allow a decoupled way of communicating changes or notifications within MMFS.  </li> <li><code>IEventListener</code> classes automatically subscribe to all events.  </li> <li>Event IDs can be manually specified or derived via the string hashing syntax <code>\"SOME_ID\"_i</code>.  </li> <li>Default events like <code>LogData</code>, <code>GPSFix</code>, and <code>BoolEvent</code> are provided for common tasks.  </li> <li><code>DefaultEventHandler</code> gives out-of-the-box functionality that you can override or remove (<code>.withNoDefaultEventListener()</code>) if you want full control.</li> <li>You can manually subscribe specific methods to the EventManager.</li> </ul> <p>By taking advantage of this flexible event system, your application can remain modular and easy to maintain, with different parts of the system responding only to the events they care about.</p> <p>Written by ChatGPT. Information may not be completely accurate.</p>"},{"location":"user-guide/ifaces/filters/","title":"Filters","text":"<p>Currently only have a 6dof Kalman filter aas an option. See the examples/Avionics folder for an example. The current system is dense and unoptimized, so is likely to change. As such, docs have not been written for it.</p>"},{"location":"user-guide/ifaces/sensor/","title":"Sensor Interface","text":"<p>The <code>Sensor</code> interface in MMFS defines a standard structure for hardware sensor modules such as barometers, GPS units, IMUs, and more. It provides a unified API for initialization, updates, and data reporting. All sensors inherit from the <code>Sensor</code> base class, which itself inherits from <code>DataReporter</code>, enabling each sensor to automatically expose its data in a standardized way for logging or telemetry.</p>"},{"location":"user-guide/ifaces/sensor/#purpose","title":"Purpose","text":"<p>This interface ensures that all sensor types in MMFS can be:</p> <ul> <li>Queried consistently (via <code>update()</code>)</li> <li>Initialized uniformly (via <code>begin()</code>)</li> <li>Identified programmatically by type</li> <li>Hooked into telemetry/logging systems via inherited <code>DataReporter</code></li> </ul>"},{"location":"user-guide/ifaces/sensor/#core-methods","title":"Core Methods","text":""},{"location":"user-guide/ifaces/sensor/#initialization","title":"Initialization","text":"<pre><code>virtual bool begin(bool useBiasCorrection = true) = 0;\n</code></pre> <p>Prepares the sensor for use. May involve hardware initialization, I2C/SPI setup, and calibration. Some sensors support optional bias correction at startup.</p>"},{"location":"user-guide/ifaces/sensor/#update","title":"Update","text":"<pre><code>virtual void update() = 0;\n</code></pre> <p>Fetches new data from the sensor. This function is called periodically (e.g., once per loop) and internally handles reading from the sensor and updating internal data buffers.</p>"},{"location":"user-guide/ifaces/sensor/#type-identification","title":"Type Identification","text":"<pre><code>virtual const SensorType getType() const = 0;\nvirtual const char *getTypeString() const = 0;\n</code></pre> <p>Returns the enum or string identifier for the sensor type. Useful for dynamic system configuration, debug messages, or logging.</p>"},{"location":"user-guide/ifaces/sensor/#datareporter-integration","title":"DataReporter Integration","text":"<p>Because <code>Sensor</code> inherits from <code>DataReporter</code>, it can expose internal sensor values to the logging and telemetry system.</p> <p>To expose a new value:</p> <pre><code>addColumn(FLOAT, &amp;temperature, \"Temp\");\n</code></pre> <p>To remove a value:</p> <pre><code>removeColumn(\"Temp\");\n</code></pre> <p>The <code>DataReporter</code> base handles linked list management of these columns, automatic formatting of values, and integration with the Logger.</p>"},{"location":"user-guide/ifaces/sensor/#bias-correction-controls","title":"Bias Correction Controls","text":""},{"location":"user-guide/ifaces/sensor/#bias-mode-toggle","title":"Bias Mode Toggle","text":"<pre><code>void setBiasCorrectionMode(bool mode);\n</code></pre> <p>Determines whether the sensor should continuously zero itself using incoming data (Used before liftoff to prevent long-term drift).</p>"},{"location":"user-guide/ifaces/sensor/#liftoff-lock-in","title":"Liftoff Lock-in","text":"<pre><code>void markLiftoff();\n</code></pre> <p>Disables any ongoing bias correction. Typically called once the rocket leaves the pad.</p>"},{"location":"user-guide/ifaces/sensor/#implementing-your-own-sensor","title":"Implementing Your Own Sensor","text":"<p>To implement your own sensor, inherit from <code>Sensor</code> and define the following:</p> <pre><code>class MySensor : public Sensor {\npublic:\n    bool begin(bool useBiasCorrection = true) override;\n    void update() override;\n    SensorType getType() const override { return OTHER_; }\n    const char* getTypeString() const override { return \"MY_SENSOR\"; }\n};\n</code></pre> <p>In the constructor, register your output values using the inherited <code>addColumn()</code> methods.</p>"},{"location":"user-guide/ifaces/sensor/#example-constructor","title":"Example Constructor","text":"<pre><code>MySensor::MySensor() {\n    addColumn(FLOAT, &amp;someValue, \"Some Value\");\n    addColumn(BOOL, &amp;statusFlag, \"Status\");\n}\n</code></pre>"},{"location":"user-guide/ifaces/sensor/#sensortype-enum","title":"SensorType Enum","text":"<pre><code>enum SensorType {\n    BAROMETER_,\n    GPS_,\n    IMU_,\n    LIGHT_SENSOR_,\n    RADIO_,\n    RTC_,\n    ENCODER_,\n    OTHER_\n};\n</code></pre> <p>Use these types to categorize your sensor. If none fit, use <code>OTHER_</code>.</p>"},{"location":"user-guide/ifaces/sensor/#summary","title":"Summary","text":"<ul> <li>All sensors inherit from <code>Sensor</code>, which requires <code>begin()</code>, <code>update()</code>, and type reporting methods.</li> <li>Sensors automatically plug into the telemetry/logging system via <code>DataReporter</code>.</li> <li>Bias correction and liftoff control allow for zeroing and stabilization of certain sensors.</li> <li>Extending the system with new sensors is easy\u2014just inherit and override.</li> </ul> <p>Written by ChatGPT. May not be fully accurate; verify before flight.</p>"},{"location":"user-guide/ifaces/state/","title":"State","text":"<p>The <code>State</code> class in MMFS serves as the central data aggregator, coordinating all sensors, optionally fusing data via a filter (e.g. a Kalman filter), and determining the current flight stage. This class is typically passed into <code>MMFSSystem</code> for high-level control of the flight software.</p>"},{"location":"user-guide/ifaces/state/#overview","title":"Overview","text":"<p>The <code>State</code> class is responsible for:</p> <ol> <li>Sensor updates \u2013 polling and managing all registered sensors</li> <li>Sensor fusion (optional) \u2013 using a provided <code>Filter</code> to compute position/velocity/acceleration</li> <li>Flight stage logic \u2013 calling a user-implemented <code>determineStage()</code> to manage the rocket\u2019s flight state machine</li> </ol>"},{"location":"user-guide/ifaces/state/#expected-usage","title":"Expected Usage","text":"<p>You are expected to subclass <code>State</code> and implement:</p> <pre><code>void determineStage() override;\n</code></pre> <p>This method determines the current flight phase (e.g., pad, boost, coast, recovery) based on sensor values like altitude, acceleration, or velocity.</p> <p>In your subclass, you'll typically query sensors like so:</p> <pre><code>auto baro = reinterpret_cast&lt;Barometer *&gt;(getSensor(BAROMETER_));\nauto imu = reinterpret_cast&lt;IMU *&gt;(getSensor(IMU_));\nfloat alt = baro ? baro-&gt;getAGLAltM() : 0;\n</code></pre>"},{"location":"user-guide/ifaces/state/#constructor","title":"Constructor","text":"<pre><code>State(Sensor **sensors, int numSensors, Filter *filter);\n</code></pre> <ul> <li><code>sensors</code>: an array of pointers to various Sensor-derived classes (e.g. GPS, IMU, Barometer)</li> <li><code>numSensors</code>: number of sensors in the array</li> <li><code>filter</code>: optional pointer to a <code>Filter</code> object for data fusion (e.g. Kalman filter)</li> </ul>"},{"location":"user-guide/ifaces/state/#lifecycle-and-core-methods","title":"Lifecycle and Core Methods","text":""},{"location":"user-guide/ifaces/state/#initialization","title":"Initialization","text":"<pre><code>bool init(bool useBiasCorrection = false);\n</code></pre> <p>Initializes all valid sensors and optionally enables bias correction. Failing sensors are disabled and logged.</p>"},{"location":"user-guide/ifaces/state/#state-update","title":"State Update","text":"<pre><code>void updateState(double currentTime = -1);\n</code></pre> <p>Called once per loop. This does the following:</p> <ol> <li>Records <code>lastTime</code> and updates <code>currentTime</code></li> <li>Calls <code>updateSensors()</code> on all valid sensors</li> <li>Calls <code>updateKF()</code> or <code>updateWithoutKF()</code> depending on filter presence</li> <li>Updates orientation, heading, and positional fields</li> <li>Finally calls <code>determineStage()</code> (which you override)</li> </ol>"},{"location":"user-guide/ifaces/state/#sensor-access","title":"Sensor Access","text":"<p>Sensors can be accessed by type using:</p> <pre><code>Sensor *getSensor(SensorType type, int sensorNum = 1);\n</code></pre> <p>Returned sensors can then be downcasted to the appropriate type (e.g. <code>Barometer</code>, <code>GPS</code>).</p>"},{"location":"user-guide/ifaces/state/#internal-state-variables","title":"Internal State Variables","text":"<p>These are updated every loop and can be queried with <code>get*()</code> methods:</p> <ul> <li><code>Vector&lt;3&gt; position</code> \u2014 Displacement in meters</li> <li><code>Vector&lt;3&gt; velocity</code> \u2014 m/s</li> <li><code>Vector&lt;3&gt; acceleration</code> \u2014 m/s\u00b2</li> <li><code>Quaternion orientation</code> \u2014 current rotation from IMU</li> <li><code>Vector&lt;3&gt; eulerAngles</code> \u2014 roll, pitch, yaw (derived)</li> <li><code>Vector&lt;2&gt; coordinates</code> \u2014 lat/lon (from GPS)</li> <li><code>float heading</code> \u2014 direction of travel</li> <li><code>int stage</code> \u2014 user-defined flight stage value</li> </ul> <p>These are all exposed via <code>DataReporter</code> for logging and telemetry.</p>"},{"location":"user-guide/ifaces/state/#kalman-filter-integration","title":"Kalman Filter Integration","text":"<p>If a <code>Filter</code> is passed into the constructor:</p> <ul> <li>It will be initialized during <code>init()</code></li> <li>Called on each <code>updateState()</code> to fuse sensor data</li> <li>Internal <code>stateVars</code> will be allocated to store the filter\u2019s output</li> </ul> <p>You must ensure your <code>Filter</code> subclass implements the expected interface (e.g., <code>initialize()</code>, <code>update()</code>, etc.).</p>"},{"location":"user-guide/ifaces/state/#example-implementation","title":"Example Implementation","text":"<pre><code>class MyAvionicsState : public State {\npublic:\n    MyAvionicsState(Sensor **s, int n, Filter *f) : State(s, n, f) {}\n\n    void determineStage() override {\n        IMU *imu = reinterpret_cast&lt;IMU *&gt;(getSensor(IMU_));\n        Barometer *baro = reinterpret_cast&lt;Barometer *&gt;(getSensor(BAROMETER_));\n\n        if (stage == 0 &amp;&amp;\n            (sensorOK(imu) ? abs(imu-&gt;getAccelerationGlobal().z()) &gt; 25 : false) ||\n            (sensorOK(baro) ? baro-&gt;getAGLAltFt() &gt; 60 : false)) {\n\n            getLogger().setRecordMode(FLIGHT);\n            stage = 1;\n            timeOfLaunch = currentTime;\n            getLogger().recordLogData(INFO_, \"Launch detected.\");\n        }\n    }\n};\n</code></pre> <p>This shows a basic launch detection using either IMU acceleration or barometric altitude.</p>"},{"location":"user-guide/ifaces/state/#integration-with-mmfssystem","title":"Integration with MMFSSystem","text":"<p>Once your <code>State</code> is initialized, pass it to MMFSSystem like so:</p> <pre><code>MyAvionicsState state(sensors, numSensors, new MyKalmanFilter());\nMMFSConfig config = MMFSConfig()\n                .withState(&amp;state)\n                // any other config options\n                ;\n</code></pre> <p>MMFSSystem will handle calling <code>updateState()</code> and routing stage transitions.</p>"},{"location":"user-guide/ifaces/state/#summary","title":"Summary","text":"<ul> <li><code>State</code> centralizes sensor access, fusion, and stage tracking</li> <li>You override <code>determineStage()</code> to define flight logic</li> <li>Sensors are polled and filtered each update cycle</li> <li>Internal state is auto-logged via <code>DataReporter</code></li> <li>Integrates directly with <code>MMFSSystem</code></li> </ul> <p>Written by ChatGPT. Information may not be accurate.</p>"},{"location":"user-guide/ifaces/sensors/baro/","title":"Barometer","text":"<p>The <code>Barometer</code> class in MMFS provides an abstract base for all barometric pressure sensors, extending the functionality of the core <code>Sensor</code> interface. It not only standardizes access to pressure data, but also computes altitude from that data, enabling derived classes to easily support telemetry and flight logic.</p>"},{"location":"user-guide/ifaces/sensors/baro/#overview","title":"Overview","text":"<p>Barometers convert pressure readings into meaningful altitude data using standard atmospheric models. The <code>Barometer</code> base class handles this transformation internally, so implementing a new sensor requires only providing raw pressure and temperature values via <code>read()</code>.</p>"},{"location":"user-guide/ifaces/sensors/baro/#inheritance-structure","title":"Inheritance Structure","text":"<p><code>Barometer</code> inherits from <code>Sensor</code> and implements many of the required pieces:</p> <ul> <li><code>begin()</code> \u2192 Calls <code>init()</code> and handles sensor startup, including zeroing pressure to define \"ground level\"</li> <li><code>update()</code> \u2192 Calls <code>read()</code> and populates altitude, pressure, and temperature values</li> </ul> <p>The only two methods you must implement in a derived class is:</p> <p><pre><code>void read() override;\nbool init() override;\n</code></pre> <code>read()</code> is intended to read the physical hardware data using the library you've found or written to talk to the sensor and update Barometer's internal variables. <code>init()</code> is designed to use said library to initialize the sensor and write and config options that you need to set to it.</p> <p>Neither of these methods are intended to any kind of complex math or variable transformation, with the potential exception of unit conversions. Anything more complex should already be handeld by Baromter's <code>update()</code> or <code>begin()</code>. Just double check that this abstract class doesn't already do the calculations that you're looking for before you write redundnat code.</p>"},{"location":"user-guide/ifaces/sensors/baro/#exposed-data-columns","title":"Exposed Data Columns","text":"<p><code>Barometer</code> automatically registers the following telemetry columns:</p> <ul> <li>Altitude (<code>alt</code>) \u2013 computed from pressure</li> <li>Pressure (<code>press</code>) \u2013 hPa</li> <li>Temperature (<code>temp</code>) \u2013 \u00b0C</li> </ul> <p>These values are exposed via the inherited <code>DataReporter</code> API and will appear in logs and live telemetry.</p>"},{"location":"user-guide/ifaces/sensors/baro/#how-altitude-is-calculated","title":"How Altitude is Calculated","text":"<p>The barometer uses the hypsometric formula to convert pressure to altitude, assuming standard atmosphere:</p> <pre><code>alt = 44330.0 * (1.0 - pow(pressure_hPa / basePressure_hPa, 0.1903));\n</code></pre> <p>Where <code>basePressure_hPa</code> is the pressure reading at ground level. This is automatically captured during <code>begin()</code>.</p>"},{"location":"user-guide/ifaces/sensors/baro/#usage-flow","title":"Usage Flow","text":"<p>To implement a new barometer driver, follow these steps:</p> <ol> <li> <p>Choose a sensor library</p> </li> <li> <p>Prefer stable and maintained libraries (e.g., Adafruit, SparkFun)</p> </li> <li> <p>Wrap it in a new class derived from <code>Barometer</code></p> </li> </ol> <pre><code>class MySensor : public Barometer {\n    AdafruitBMP390 hw;\npublic:\n    bool begin(bool useBiasCorrection = true) override {\n        hw.begin();\n        return Barometer::begin(useBiasCorrection);\n    }\n\n    bool read(float &amp;pressure_hPa, float &amp;temperature_C) override {\n        pressure_hPa = hw.readPressure();\n        temperature_C = hw.readTemperature();\n        return true;\n    }\n};\n</code></pre> <ol> <li>If you're using MMFSSystem, then that's it. Pass an instance of your new barometer to State, and the software will take care of the rest. If you're not using MMFSSystem, you should call <code>myBaro.begin()</code> in <code>setup()</code> and <code>myBaro.update()</code> in <code>loop()</code>, at whatever frequency you find works best.</li> </ol>"},{"location":"user-guide/ifaces/sensors/baro/#available-built-in-drivers","title":"Available Built-in Drivers","text":"<p>The following sensors are currently supported in MMFS:</p> <ul> <li>BMP280 - Datasheet (NRND)</li> <li>BMP390 - Datasheet</li> <li>DPS310/DPS368 - Datasheet (DPS310 is NRND) and Datasheet</li> <li>MS5611 - Datasheet</li> </ul> <p>Each of these classes derives from <code>Barometer</code> and implements the required <code>read()</code> and <code>init()</code> methods.</p>"},{"location":"user-guide/ifaces/sensors/baro/#advanced-options","title":"Advanced Options","text":""},{"location":"user-guide/ifaces/sensors/baro/#using-bias-correction-mode","title":"Using Bias Correction Mode","text":"<p>Bias correction mode helps compensate for slow pressure drift and sensor noise by continuously recalibrating the zero-altitude baseline \u2014 essentially adjusting what the barometer considers \"ground level.\" This is especially useful when the vehicle stays on the pad for a long time before launch, or when ambient pressure changes slightly.</p> <p>However, it\u2019s off by default because blindly recalibrating can be dangerous \u2014 especially if the rocket has already left the ground. See the MMFSSystem docs for more on the risks and defaults.</p> <p>When enabled, the barometer periodically computes a new baseline using the second-to-last second of recent pressure data \u2014 not the most recent second. Why? Because launch detection systems typically rely on altitude changes to identify liftoff. Including very recent data (which may already show movement) would confuse this logic and result in a bad zero point. Using the \"2nd-to-last\" second instead gives you a quieter, more accurate reference without interfering with launch detection.</p> <p>You can enable or disable this feature at any time using:</p> <pre><code>myBaro.setBiasCorrectionMode(true); // or false\n</code></pre> <p>And you should lock in the baseline permanently at liftoff by calling:</p> <pre><code>myBaro.markLiftoff();\n</code></pre> <p>This disables further corrections and locks the AGL altitude reference point in place.</p>"},{"location":"user-guide/ifaces/sensors/baro/#accessing-raw-data","title":"Accessing Raw Data","text":"<p>The following methods are available for reading the latest values:</p> <pre><code>virtual double getPressure() const; // hPa\nvirtual double getTemp() const; // Deg C\nvirtual double getTempF() const; //Deg F\nvirtual double getPressureAtm() const; // atm\nvirtual double getASLAltFt() const; // Above Sea Level - Ft\nvirtual double getASLAltM() const;  // Above Sea Level - M\nvirtual double getAGLAltM() const;  // Above Ground Level - M\nvirtual double getAGLAltFt() const; // Above Ground Level - Ft\n</code></pre> <p>Above Ground Level is either denoted as alt difference since boot up, or, if you are using bias Correction, difference since bias correction was disabled.</p>"},{"location":"user-guide/ifaces/sensors/baro/#summary","title":"Summary","text":"<ul> <li><code>Barometer</code> simplifies pressure \u2192 altitude conversion using standard math</li> <li>Hardware implementations must only define a <code>read()</code> method</li> <li><code>begin()</code> auto-calibrates base pressure and <code>update()</code> calls your driver</li> <li>Output is integrated with the MMFS logging/telemetry stack via <code>DataReporter</code></li> <li>Easy to extend using any existing Arduino/C++ pressure sensor library</li> </ul> <p>Note</p> <p>The <code>Barometer</code> class is meant for atmospheric sensors. Do not use it for water pressure sensors or sealed altimeters without modifying the pressure-to-altitude logic.</p> <p>Written by ChatGPT. May not be fully accurate; verify against source.</p>"},{"location":"user-guide/ifaces/sensors/enc/","title":"Encoder","text":"<p>The <code>Encoder_MMFS</code> class provides a standard MMFS interface for rotary or linear encoders. It inherits from <code>Sensor</code> and implements the familiar MMFS lifecycle (<code>begin()</code>, <code>update()</code>), while requiring only simple hardware-specific methods to be overridden.</p>"},{"location":"user-guide/ifaces/sensors/enc/#overview","title":"Overview","text":"<p>The encoder tracks step counts \u2014 ticks of a shaft or linear scale \u2014 relative to its startup position. It is commonly used for measuring angular rotation, wheel travel, or simple mechanical motion.</p> <p>Internally, the <code>Encoder_MMFS</code> class handles lifecycle integration and telemetry exposure. You only need to implement two functions:</p> <pre><code>bool init() override;\nvoid read() override;\n</code></pre> <ul> <li><code>init()</code> sets up your encoder hardware (e.g., pin modes, timers, interrupts)</li> <li><code>read()</code> fetches the current number of steps and updates internal variables</li> </ul>"},{"location":"user-guide/ifaces/sensors/enc/#inheritance-structure","title":"Inheritance Structure","text":"<p><code>Encoder_MMFS</code> inherits from <code>Sensor</code>, and therefore implements:</p> <ul> <li><code>begin()</code> \u2192 Calls <code>init()</code> and stores whether bias correction is enabled</li> <li><code>update()</code> \u2192 Calls <code>read()</code> and then updates the telemetry data buffer</li> </ul> <p>This ensures your encoder integrates seamlessly with MMFSSystem and the logging stack.</p>"},{"location":"user-guide/ifaces/sensors/enc/#exposed-data-columns","title":"Exposed Data Columns","text":"<p>The encoder automatically registers the following telemetry column:</p> <ul> <li>Steps (<code>Rel Steps</code>) \u2013 integer number of encoder steps since initialization</li> </ul> <p>These are reported through the <code>DataReporter</code> API and appear in logs and telemetry streams.</p>"},{"location":"user-guide/ifaces/sensors/enc/#usage-flow","title":"Usage Flow","text":"Using an EncoderImplementing a Custom Encoder <pre><code>MyEncoder encoder;\nencoder.begin();\n\nloop() {\n    encoder.update();\n    int ticks = encoder.getSteps();\n}\n</code></pre> <p>To add a hardware-specific encoder driver, subclass <code>Encoder_MMFS</code> and implement <code>init()</code> and <code>read()</code>:</p> <pre><code>class MyEncoder : public Encoder_MMFS {\n    MyHardwareEncoder hw;\n\n    bool init() override {\n        return hw.begin(); // or whatever init call the library uses\n    }\n\n    void read() override {\n        currentRelativeSteps = hw.getSteps();\n    }\n};\n</code></pre>"},{"location":"user-guide/ifaces/sensors/enc/#summary","title":"Summary","text":"<ul> <li><code>Encoder_MMFS</code> provides a standard interface for step-counting encoders</li> <li>Override <code>init()</code> and <code>read()</code> to integrate your own hardware</li> <li>Automatically hooks into MMFS telemetry and logging</li> <li>Supports packed telemetry for bandwidth-sensitive applications</li> </ul> <p>Written by ChatGPT. May not be fully accurate; verify against source.</p>"},{"location":"user-guide/ifaces/sensors/gps/","title":"GPS","text":"<p>The <code>GPS</code> class in MMFS provides a standard interface for satellite-based positioning modules. Like all sensors in MMFS, it inherits from <code>Sensor</code>, allowing it to integrate directly with the system\u2019s data reporting and state machine infrastructure. However, it also offers specific features like positional tracking, fix quality monitoring, and displacement-from-origin calculations.</p>"},{"location":"user-guide/ifaces/sensors/gps/#overview","title":"Overview","text":"<p>GPS modules output geographic location, altitude, speed, and timing information. The MMFS <code>GPS</code> class manages parsing, tracking fix quality, and computing displacement from the original location, so you don\u2019t have to.</p>"},{"location":"user-guide/ifaces/sensors/gps/#inheritance-structure","title":"Inheritance Structure","text":"<p><code>GPS</code> inherits from <code>Sensor</code>, so it exposes <code>begin()</code> and <code>update()</code> as part of its standard API:</p> <ul> <li><code>begin()</code> \u2192 Initializes the module, sets the origin once a valid fix is obtained</li> <li><code>update()</code> \u2192 Retrieves the latest fix and updates all internal values</li> </ul> <p>You only need to override two methods:</p> <pre><code>bool init() override;\nvoid read() override;\n</code></pre> <ul> <li><code>init()</code> should configure the underlying hardware (e.g., set baud rate, GPS mode, power state)</li> <li><code>read()</code> should parse data from the GPS module and update the internal position, heading, and fix fields</li> </ul> <p>This mirrors the behavior seen in other sensors like <code>Barometer</code>.</p>"},{"location":"user-guide/ifaces/sensors/gps/#exposed-data-columns","title":"Exposed Data Columns","text":"<p>The <code>GPS</code> class exposes the following telemetry columns:</p> <ul> <li>Latitude (<code>lat</code>) \u2013 degrees</li> <li>Longitude (<code>lon</code>) \u2013 degrees</li> <li>Altitude (<code>alt</code>) \u2013 meters</li> <li>Fix Quality (<code>fix</code>) \u2013 number of connected satellites (or equivalent measure)</li> <li>Heading (<code>head</code>) \u2013 degrees</li> </ul> <p>These columns are registered using the <code>DataReporter</code> system and appear automatically in logs and telemetry.</p>"},{"location":"user-guide/ifaces/sensors/gps/#displacement-and-origin-tracking","title":"Displacement and Origin Tracking","text":"<p>The GPS class tracks three core positional vectors:</p> <ul> <li><code>position</code> \u2013 the current fix (lat, lon, alt)</li> <li><code>origin</code> \u2013 the first valid fix after boot (lat, lon, alt)</li> <li><code>displacement</code> \u2013 the relative XYZ distance (in meters) between current position and origin</li> </ul> <p>This makes it easy to track launch site-relative movement without needing external references.</p> <p>Note</p> <p>The distance calculation is taken from this article and this repo. As I (Drew) understand it, it's an accurate approximation of the Vincenty formulae to find the distance between two points on the earth.</p>"},{"location":"user-guide/ifaces/sensors/gps/#time-and-heading-utilities","title":"Time and Heading Utilities","text":"<p>MMFS GPS also tracks the time-of-day from the satellite fix. You can access it with:</p> <pre><code>const char *getTimeOfDay() const;\n</code></pre> <p>It also computes the travel heading in degrees:</p> <pre><code>double getHeading() const;\n</code></pre> <p>This is generally based on the change in GPS position across updates.</p>"},{"location":"user-guide/ifaces/sensors/gps/#usage-flow","title":"Usage Flow","text":"Using a GPS ModuleImplementing Your Own GPS Driver <p>If you're using an MMFS-supported GPS driver:</p> <pre><code>MyGPS gps;\ngps.begin();\n\nloop() {\n    gps.update();\n    if (gps.getHasFirstFix()) {\n        Vector&lt;3&gt; pos = gps.getPos();\n        Vector&lt;3&gt; disp = gps.getDisplacement();\n    }\n}\n</code></pre> <p>GPS fixes typically take a few seconds to stabilize. Use <code>getHasFirstFix()</code> to avoid reading garbage data.</p> <p>To add a new GPS module:</p> <ol> <li>Find a library that parses NMEA or binary output from your hardware</li> <li> <p>Create a new class derived from <code>GPS</code>:</p> <pre><code>class MyGPS : public GPS {\n    SomeLibGPS hw;\npublic:\n    bool init() override {\n        hw.begin(9600);\n        return true;\n    }\n    void read() override {\n        hw.read();\n        if (hw.hasFix()) {\n            position = { hw.latitude(), hw.longitude(), hw.altitude() };\n            fixQual = hw.fixQuality();\n            heading = hw.headingDegrees();\n        }\n    }\n};\n</code></pre> </li> <li> <p>Call <code>begin()</code> and <code>update()</code> as in the usage example.</p> </li> </ol>"},{"location":"user-guide/ifaces/sensors/gps/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/ifaces/sensors/gps/#using-bias-correction-mode","title":"Using Bias Correction Mode","text":"<p>Bias correction mode in the GPS module serves the same core purpose as it does for the barometer: stabilizing the baseline reference \u2014 in this case, your origin point (lat, lon, alt). Instead of relying on a single fix, it smooths out noise and minor drift by averaging over several recent GPS readings.</p> <p>By default, the origin is set the first time a valid fix is obtained. If bias correction is enabled, MMFS continues updating this origin using the second-to-last second of position data. This helps reduce the effect of GPS jitter or slow drift while the rocket is sitting still.</p> <p>Why not use the most recent second? Same reason as with pressure sensors \u2014 the moment just before launch may already contain motion. Locking in a slightly older, averaged position provides a cleaner and safer ground reference for computing AGL altitude or displacement.</p> <p>To toggle this feature:</p> <p><pre><code>myGps.setBiasCorrectionMode(true);  // enable smoothing\nmyGps.setBiasCorrectionMode(false); // freeze origin\n</code></pre> And once you're confident the rocket has launched or the vehicle is moving, lock in the reference point permanently:</p> <pre><code>myGps.markLiftoff();\n</code></pre> <p>From that point onward, the origin stays fixed and all displacement values are computed relative to it.</p>"},{"location":"user-guide/ifaces/sensors/gps/#summary","title":"Summary","text":"<ul> <li><code>GPS</code> standardizes satellite position data in MMFS</li> <li>You only need to implement <code>init()</code> and <code>read()</code> to add new modules</li> <li>Outputs latitude, longitude, altitude, fix quality, and heading</li> <li>Tracks local displacement and satellite time-of-day</li> <li>Integrates with MMFS telemetry/logging and supports packed data</li> </ul> <p>Written by ChatGPT. May not be fully accurate; verify against source.</p>"},{"location":"user-guide/ifaces/sensors/imu/","title":"IMU","text":"<p>The <code>IMU</code> class in MMFS represents an advanced inertial sensor interface designed to support both raw sensor reporting and fused orientation estimation. It processes data from gyroscopes, accelerometers, and optionally magnetometers, and internally runs a quaternion-based complementary filter to estimate device orientation.</p> <p>Unlike basic sensors, IMUs operate in a multi-frame context \u2014 reporting both local-frame measurements and global-frame acceleration \u2014 and may expose both raw and filtered signals. Orientation is represented using quaternions but is often interpreted in Euler angles for ease of telemetry.</p>"},{"location":"user-guide/ifaces/sensors/imu/#overview","title":"Overview","text":"<p>An IMU in MMFS provides:</p> <ul> <li>Angular velocity (from gyroscope)</li> <li>Linear acceleration (from accelerometer)</li> <li>Magnetic field strength (from magnetometer)</li> <li>Quaternion orientation (internally computed)</li> <li>Gravity-compensated acceleration (global frame)</li> </ul>"},{"location":"user-guide/ifaces/sensors/imu/#inheritance-structure","title":"Inheritance Structure","text":"<p><code>IMU</code> inherits from <code>Sensor</code> and expects the user to override two core methods:</p> <pre><code>bool init() override;\nvoid read() override;\n</code></pre> <ul> <li><code>init()</code> sets up the hardware driver(s), configures sensors, and prepares communication.</li> <li> <p><code>read()</code> must populate the following fields with current measurements:</p> </li> <li> <p><code>measuredAcc</code> \u2014 linear acceleration in body frame</p> </li> <li><code>measuredGyro</code> \u2014 angular velocity in deg/s</li> <li><code>measuredMag</code> \u2014 magnetic field vector (optional)</li> </ul> <p>The class handles filtering and fusion internally during <code>update()</code>.</p>"},{"location":"user-guide/ifaces/sensors/imu/#orientation-fusion","title":"Orientation Fusion","text":"<p>The <code>IMU</code> class performs sensor fusion using a quaternion-based complementary filter. This combines fast-but-drifting gyro data with stable-but-noisy accelerometer estimates of gravity direction. Magnetometers can further improve yaw stability.</p> <p>The computed orientation is stored in:</p> <pre><code>Quaternion orientation;\n</code></pre> <p>Global-frame acceleration (i.e. gravity-compensated) is computed using:</p> <pre><code>Vector&lt;3&gt; getAccelerationGlobal();\n</code></pre> <p>and is derived by rotating the measured acceleration vector into the world frame.</p>"},{"location":"user-guide/ifaces/sensors/imu/#exposed-data-columns","title":"Exposed Data Columns","text":"<p>The IMU automatically exposes the following:</p> <ul> <li><code>accX</code>, <code>accY</code>, <code>accZ</code> \u2014 linear acceleration (m/s\u00b2)</li> <li><code>gyroX</code>, <code>gyroY</code>, <code>gyroZ</code> \u2014 angular velocity (deg/s)</li> <li><code>magX</code>, <code>magY</code>, <code>magZ</code> \u2014 magnetic field (\u03bcT)</li> <li><code>oriX</code>, <code>oriY</code>, <code>oriZ</code>, <code>oriW</code> \u2014 quaternion orientation</li> </ul> <p>These are registered for logging and telemetry via <code>DataReporter</code> and packed for transmission.</p>"},{"location":"user-guide/ifaces/sensors/imu/#bias-correction-mode","title":"Bias Correction Mode","text":"<p>Bias correction enables zeroing gyro and acceleration offsets over time. If enabled before flight, the IMU will average recent values to zero-out drift while stationary.</p> <pre><code>imu.setBiasCorrectionMode(true);\nimu.markLiftoff(); // Locks in calibration at launch\n</code></pre> <p>Avoid enabling this while the vehicle is moving.</p>"},{"location":"user-guide/ifaces/sensors/imu/#usage-flow","title":"Usage Flow","text":"Using an IMUImplementing a Custom IMU <pre><code>MyIMU imu;\nimu.begin();\n\nloop() {\n    imu.update();\n    Quaternion q = imu.getOrientation();\n    Vector&lt;3&gt; a_global = imu.getAccelerationGlobal();\n}\n</code></pre> <pre><code>class MyIMU : public IMU {\n    MyIMULib hw;\n\n    bool init() override {\n        return hw.begin();\n    }\n\n    void read() override {\n        measuredAcc = { hw.ax(), hw.ay(), hw.az() };\n        measuredGyro = { hw.gx(), hw.gy(), hw.gz() };\n        measuredMag = { hw.mx(), hw.my(), hw.mz() }; // optional\n    }\n};\n</code></pre>"},{"location":"user-guide/ifaces/sensors/imu/#built-in-implementations","title":"Built-in Implementations","text":""},{"location":"user-guide/ifaces/sensors/imu/#bmi088-lis3mdl","title":"BMI088 + LIS3MDL","text":"<ul> <li>Combines separate accelerometer, gyro, and magnetometer</li> <li>Uses MMFS\u2019s internal filter and fusion logic</li> <li>Best for flexible, high-performance inertial applications</li> </ul>"},{"location":"user-guide/ifaces/sensors/imu/#bno055","title":"BNO055","text":"<ul> <li>Integrated 9DOF sensor with onboard fusion</li> <li>MMFS defers to the sensor\u2019s internal orientation logic</li> <li>Returns pre-filtered quaternion and acceleration data</li> </ul>"},{"location":"user-guide/ifaces/sensors/imu/#advanced-controls","title":"Advanced Controls","text":"<p>The following parameters can be adjusted to control noise filtering sensitivity during static startup:</p> <pre><code>imu.setAccelBestFilteringAtStatic(val); // threshold for accel stability\nimu.setMagBestFilteringAtStatic(val);   // threshold for mag stability\n</code></pre> <p>Use these to tune how long the IMU waits before accepting a bias-corrected origin.</p>"},{"location":"user-guide/ifaces/sensors/imu/#summary","title":"Summary","text":"<ul> <li>Implements <code>Sensor</code> with IMU-specific orientation logic</li> <li>Expects raw accel, gyro, and optional mag readings</li> <li>Computes quaternion orientation using a complementary filter</li> <li>Supports packed telemetry and gravity-compensated acceleration</li> <li>Used directly or as a base class for sensor-specific drivers</li> </ul> <p>Written by ChatGPT. May not be fully accurate; verify against source.</p>"},{"location":"user-guide/ifaces/sensors/light/","title":"LightSensor","text":"<p>idk maybe</p>"},{"location":"user-guide/utils/blinkbuzz/","title":"BlinkBuzz","text":"<p>This utility is designed to be used as-is, without the end user (you) having to overload or otherwise modify it. It is an asynchronous utility for outputting patterned buzzes and LED blinks. It can be used to create simple patterns, such as beeping a certain number of times, or more complex patterns, such as SOS in morse code. It can also be used to create patterns that repeat indefinitely or patterns that repeat a specific number of times. It is designed to be easy to use and flexible enough to handle a wide variety of use cases.</p>"},{"location":"user-guide/utils/blinkbuzz/#setup","title":"Setup","text":"<p>We strongly recommend that you use the <code>MMFSSystem</code> and <code>MMFSConfig</code> objects whenever you use MMFS. That said, all utilities have the ability to be used outside of <code>MMFSSystem</code>, including BlinkBuzz. The only difference between the two is the setup. All other functions are identical.</p> With MMFSSystemWithout MMFSSystem <p>BlinkBuzz does not have too many configuration options. Here they are, shown with their default values if they have them:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nint GPS_STATUS_PIN = 25;\n\nMMFSConfig config = MMFSConfig()\n                    .withBuzzerPin(int pinNum) // no default\n                    .withBBPin(int pinNum) // add any pin you'd like, no default\n                    .withBBPin(int pinNum) // add as many pins as you want, no default\n                    .withBBAsync(true, 50); // allow async patterns, max queue size of 50.\n\nMMFSSystem system = MMFSSystem(config);\n</code></pre> <p>In <code>setup()</code> you must call <code>system.init()</code> to initialize the system. This will also initialize the BlinkBuzz utility.</p> <p>In order to take advantage of the async features, you must call <code>system.update()</code> in your <code>loop()</code>. This will also update the BlinkBuzz utility.</p> <p>If you do not wish to use the MMFSSystem, you can use BlinkBuzz as a standalone utility. You must however set up the object yourself, and remember to call <code>bb.update()</code> in your <code>loop()</code>. </p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nint *allowedPins[] = { LED_BUILTIN, 33 };\nBlinkBuzz bb; //define a global variable that is declared in the Blinkbuzz.h file for easy access across files\n\ndouble lastTime = 0; // See loop()\n\nsetup() {\n    bb.init(allowedPins, 2, true, 50); // allowed pins, number of pins, allow usage of async patterns, Max queue size per pin (async mode only)\n    //NOTE: Max queue size refers to the number of on and off toggles that are performed, so ON -&gt; OFF is 2 spots in the queue.\n}\n\nloop()\n{\n    bb.update(); // The more frequently this is called, the more accurate the timing will be.\n\n    // We recommend not using a delay() call for loop iterations when using async patterns.\n    // Instead, maybe try something like this:\n\n    double time = millis();\n    if(time - lastTime &lt; DESIRED_INTERVAL) // however much you would have otherwise delay()ed for\n        return;\n    lastTime = time; // lastTime = global variable\n\n    // the rest of your loop code here\n}\n</code></pre> <p>Warning</p> <p>There is a moderate memory overhead associated with using async patterns. Keep queue sizes as small as is reasonable.</p>"},{"location":"user-guide/utils/blinkbuzz/#usage","title":"Usage","text":"<p>In any file that includes BlinkBuzz, you can use any of the BlinkBuzz functions. </p>"},{"location":"user-guide/utils/blinkbuzz/#synchronous-usage","title":"Synchronous usage","text":"<p>These are the calls you would make while in <code>setup()</code> or if you disable async usage.</p> <p>Note</p> <p><code>BBPattern</code> arguments are not supported in synchronous function calls, nor are they planned to be in the future.</p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nvoid setup() {\n\n    // Simply hold the pin on/off:\n    bb.on(BUZZER);  // turn on\n    bb.off(BUZZER); // turn off\n\n    //Patternize\n    bb.onoff(BUZZER, 200, 3, 100); // beep 3 times, 200ms on, 100ms off\n    // OR\n    bb.onoff(BUZZER, 200, 5);      // beep 5x, 200ms on, 200ms off\n    // OR\n    bb.onoff(BUZZER, 200);         // beep 1x, 200ms on\n}\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#async-usage","title":"Async Usage","text":"<p>Asynchronous use was the reason BlinkBuzz came to be in the first place, and is what makes the utility so valuable and powerful. You can blink lights in custom patterns indefinitely, without blocking the rest of your code. This is invaluable during testing as the buzzer can beep to indicate state changes without stopping the State from updating.</p>"},{"location":"user-guide/utils/blinkbuzz/#old-school","title":"Old-School","text":"<p>Here are the most basic examples of how to use the async functions: <pre><code>    bb.aonoff(BUZZER, 200, 3, 100); // beep 3 times, 200ms on, 100ms off\n    // OR\n    bb.aonoff(BUZZER, 200, 5);      // beep 5x, 200ms on, 200ms off\n    // OR\n    bb.aonoff(BUZZER, 200);         // beep 1x, 200ms on\n\n    // Can clear a pin's queue:\n    bb.clearQueue(BUZZER);\n</code></pre></p>"},{"location":"user-guide/utils/blinkbuzz/#bbpattern","title":"BBPattern","text":"<p>You can also use the <code>BBPattern</code> class to build complex patterns. You define a pattern  with the same arguments as <code>onoff()</code>, but you can also append patterns to each other, and add \"rests\" to the end of a pattern. You may then call the pattern with <code>aonoff()</code> with any pin.</p> <pre><code>    BBPattern pattern = BBPattern(ON_DURATION, REPEATS, OFF_DURATION);\n    // For example, to build an SOS pattern, build the S and O letters:\n    BBPattern s(50, 3, 200);\n    BBPattern o(500, 3, 200);\n    // Then, append them to each other to build a single SOS pattern using the `a()` function:\n    BBPattern sos;\n    sos.a(s).a(o).a(s);\n    //NOTE: do not do BBPattern sos = s.a(o).a(s); as this will not work as expected. Minor bug.\n    // Then call it\n    bb.aonoff(BUZZER, sos);\n\n    // To repeat a pattern indefinitely, use the following:\n    bb.aonoff(BUZZER, sos, true);\n\n    // You can also append a \"rest\" to the end of a pattern, changing it's final duration.\n    bb.aonoff(BUZZER, sos.r(1000), true); // Rest for 1 second between the SOS patterns\n    //The rest can be added inline like this or to the pattern object itself.\n\n    // Appending patterns and adding rests can be done in any order as many times as you wish (so long as you have the queue space to hold them)\n}\n</code></pre>"},{"location":"user-guide/utils/circbuf/","title":"CircBuffer","text":"<p>This class is exactly what it sounds like. It uses an array based implementation of a queue to hold a buffer of any kind of object. Internally, it's used as part of the Sensor drift correction system to store data for averaging, but it can realistically be used for anything.</p>"},{"location":"user-guide/utils/circbuf/#usage","title":"Usage","text":"<p>Initialization and adding/removing: <pre><code>#include &lt;CircBuffer.h&gt;\n\n// Create a circular buffer of 10 integers\nCircBuffer&lt;int&gt; buffer(10);\n// Add an element to the buffer\nbuffer.push(1);\n// See top of the queue\nint top = buffer.peek();\n// Pop an element from the buffer\nint popped = buffer.pop();\n</code></pre></p> <p>There are also these other standard functions, that do about what you'd expect: <pre><code>bool isEmpty();\nbool isFull();\nint getSize(); // capacity of buffer\nint getCount(); // number of elements in buffer\nvoid clear();\n</code></pre></p> <p>Finally, you can use the <code>[]</code> operator to access elements. <code>buffer[0]</code> is the top of the queue, and <code>buffer[buffer.getCount() - 1]</code> is the bottom.</p>"},{"location":"user-guide/utils/logger/","title":"Logger","text":"<p>Note</p> <p>It is very likely that this class has minor changes to to the way it is set up in the future. Please verify that the website footer indicates the correct MMFS version number.</p> <p>The Logger class is one of the most powerful, but also one of the most complicated systems in MMFS. It can take both log data and flight data and write them to onboard storage or USB. It (by default) performs less frequent writes during pre- and post-flight periods to prevent writing unnecessary data. Additionally, it can modify the date of file creation so it is accurate once an onboard GPS obtains a time fix (Not currently working). Finally, if it crashes, it will log the reason for the crash the next time it boots.</p> <p>With all this functionality, there are numerous configuration options to choose from, so feel free to jump to a specific section using the table of contents on the right.</p>"},{"location":"user-guide/utils/logger/#setup","title":"Setup","text":"<p>The first thing to know about the Logger class is that it exists as a singleton, accessed via the global <code>getLogger()</code> method. Every time you need to use any of the Logger\u2019s functions, you should prefix them with <code>getLogger()</code> followed by the function call.</p> <p>We strongly recommend using the <code>MMFSSystem</code> and <code>MMFSConfig</code> objects whenever you use MMFS, as they handle almost all initialization tasks for you. However, all utilities can be used outside of <code>MMFSSystem</code>, including Logger. The only difference between these two approaches is the setup. All other functions are identical.</p> With MMFSSystemWithout MMFSSystem <p>Here is a list of the <code>MMFSConfig</code><sup>1</sup> options relevant to Logger:</p> <p>These defaults should be fine for most use cases. The defaults are shown below:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nMMFSConfig config = MMFSConfig()\n                    .withOtherDataReporters(DataReporter **others) // Add additional objects that can report flight data\n                    .withLogPrefixFormatting(\"$time - [$logType] \"); // Change format string for log data (must include $time and $logType)\n</code></pre> <p>If you simply want to use Logger without <code>MMFSSystem</code>, you need to call <code>getLogger().init()</code> with the default parameters. You must pass all the DataReporter objects (including State and all its sensors) and their count. You can also pass in the buffer time and buffer interval variables. Check if it worked with <code>getLogger().isReady()</code>. At the end of setup (after all of the data reporters are initialized), you should call <code>getLogger().writeCsvHeader()</code> to write the initial line to the SD card.</p> <pre><code>#include &lt;Logger.h&gt;\n\nsetup() {\n    // Example:\n    DataReporter *reporters[] = { &amp;state, &amp;sensor1, &amp;sensor2, ... };\n    getLogger().init(reporters, numberOfReporters, 30, 30);\n    if (getLogger().isReady()) {\n        getLogger().writeCsvHeader();\n    }\n}\n</code></pre>"},{"location":"user-guide/utils/logger/#recording-log-data","title":"Recording Log Data","text":""},{"location":"user-guide/utils/logger/#before-you-begin","title":"Before You Begin","text":"<p>All log data is recorded to a file called <code>###_Log.txt</code>, where ### is an incrementor based on files already existing in the file system (So largest # = newest file). It prefixes all log entries with a timestamp and a log type. The log types are:</p> <ul> <li><code>INFO_</code>: General system information (default).</li> <li><code>WARNING_</code>: A warning about a potential issue.</li> <li><code>ERROR_</code>: An error that has occurred.</li> <li><code>LOG_</code>: A log entry that is not an error or warning.</li> <li><code>CUSTOM_</code>: A log entry with a custom prefix.</li> </ul> <p>You can change the format of the default log types before calling <code>getLogger().init()</code> by calling:</p> <pre><code>getLogger().setLogPrefixFormatting(const char *prefix);\n</code></pre> <p>The default is <code>\"$time - [$logType] \"</code>, which will produce something like <code>0.000 - [INFO] Hello, world!</code>. When you call this function, you must include the keywords <code>$time</code> and <code>[$logType]</code>. <code>$time</code> is replaced with the time (in seconds) since the microcontroller turned on (printed with 3 decimal places), and <code>[$logType]</code> is replaced with the log type stamp. You can include any additional text you like.</p> <p>You may change the log prefix for the custom log type by calling:</p> <pre><code>getLogger().setCustomLogPrefix(const char *prefix);\n</code></pre> <p>The default is <code>\"$time - [CUSTOM] \"</code>, which would output something like <code>0.000 - [CUSTOM] Hello, world!</code>. Including <code>$time</code> is recommended but not required. This method can be called at any time, and the custom prefix will remain until overridden by a subsequent call.</p> <p>When you record log data, you can send it to the SD card, USB serial, or both. The default behavior is to record to both. These options exist in the <code>Dest</code> enum:</p> <pre><code>enum Dest {\n    TO_FILE,\n    TO_USB,\n    BOTH\n};\n</code></pre>"},{"location":"user-guide/utils/logger/#recording-data","title":"Recording Data","text":"<p>Once setup is complete, you can record log data using:</p> <pre><code>getLogger().recordLogData(...);\n</code></pre> <p>There are eight different function overloads for this method, each taking different arguments. Essentially, you specify the log type, where you want to send it (destination), and the actual data you want to log. You can optionally supply a timestamp instead of letting it be generated automatically, and you can choose to use or not use a printf-style format string followed by any number of arguments. Rather than list every overload, here are a couple of examples:</p> <pre><code>getLogger().recordLogData(WARNING_, TO_USB, \"Hello, world!\");\ngetLogger().recordLogData(INFO_, TO_FILE, 50, \"Hello %s\", \"there!\");\n</code></pre> <p>Note</p> <p>If you use the format string versions of the method, you must provide an integer representing the maximum length you expect the string to be once formatted (50 in this example).</p> <p>Once the data is logged to its destination, Logger will fire a <code>LogData</code> event with the ID <code>\"LOG_DATA\"_i</code><sup>2</sup>. You can listen for this event if you want to do something additional with the logged data.</p>"},{"location":"user-guide/utils/logger/#recording-flight-data","title":"Recording Flight Data","text":""},{"location":"user-guide/utils/logger/#before-you-begin_1","title":"Before You Begin","text":"<p>Flight data is stored in two files: a preflight data file and a flight data file. By default, it only stores pre- and post-flight data once every 30 seconds. This is why having a robust State with proper launch detection is important. By default, it also stores the most recent 30 seconds of data before launch at the full data rate. You can change this behavior by modifying the buffer time and buffer interval parameters in the init function. To write all data directly to the SD card, set the buffer interval to zero. To write no data to the SD card and store everything in PSRAM until landing is detected, set the buffer interval to less than zero.</p> <p>The Logger currently supports two types of file storage hardware. a MicroSD card, plugged into the slot on the Teensy, and QSPI NAND Flash, soldered onto the bottom of the board. The logger prefers using the flash memory for robustness reasons, but will fallback to the SD card if flash is not detected.</p> <p>All functionality surrounding flight and preflight data is managed by an internal enum called <code>Mode</code>. By default, the mode is <code>GROUND</code>. Once you call:</p> <pre><code>getLogger().setMode(FLIGHT);\n</code></pre> <p>the Logger assumes the rocket has just launched and switches into flight mode. When landing is detected, simply call:</p> <pre><code>getLogger().setMode(GROUND);\n</code></pre> <p>and the Logger will switch back to pre-/post-flight data mode.</p>"},{"location":"user-guide/utils/logger/#recording-data_1","title":"Recording Data","text":"<p>If you use the MMFSSystem objects, this is done automatically when you call <code>system.update()</code> in your loop. If you are not using the MMFSSystem objects, you must call:</p> <pre><code>getLogger().recordFlightData();\n</code></pre> <p>in your loop to record flight data. This method automatically detects the mode and logs the appropriate data. The order of columns in the CSV file is determined by the order of the data reporter objects passed to the Logger. If you use MMFSSystem, this will be the State followed by all sensors in the order they were passed to the State, then anything else added later.</p>"},{"location":"user-guide/utils/logger/#miscellaneous","title":"Miscellaneous","text":""},{"location":"user-guide/utils/logger/#changing-the-creation-date-of-files","title":"Changing the Creation Date of Files","text":"<p>Unfortunately, the SD card itself has no concept of real-world time. However, most flight systems have a GPS onboard, and by taking advantage of the default GPS event, MMFS will attempt to set correct creation and modification dates for all files on the SD card, making them easier to manage later. This is handled by default through the default event handler<sup>2</sup>. If you disabled the default event handler, you can still modify file dates by calling:</p> <pre><code>getLogger().modifyFileDates(GPS *gps);\n</code></pre>"},{"location":"user-guide/utils/logger/#crashreport","title":"CrashReport","text":"<p>This is another feature of Logger. It has no configuration options, but it is helpful to have. If the Teensy detects a crash, a crash report object is created, and the Logger will attempt to record it in the <code>###_Log.txt</code> file on the next boot.</p> <ol> <li> <p>MMFSConfig from MMFSSystem \u21a9</p> </li> <li> <p>Event \u21a9\u21a9</p> </li> </ol>"},{"location":"user-guide/utils/math/","title":"Math","text":""},{"location":"user-guide/utils/math/#matrix","title":"Matrix","text":"<p>The Matrix class is designed for use with Kalman filters. It is based on a simple array of doubles and supports most matrix operations, including addition, subtraction, multiplication, transposition, and inversion.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Dynamically allocate memory for a 3x3 matrix\ndouble* data = new double[3 * 3]{\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n};\n\nMatrix m1 = Matrix(3, 3, data);\n// Perform matrix operations here...\n</code></pre> <p>Warning</p> <p>The Matrix class takes ownership of the array passed through its constructor and only makes a shallow copy. This means that: - The array must be dynamically allocated (i.e., allocated on the heap) rather than on the stack. - You should not modify or delete the array after passing it to the Matrix constructor.</p>"},{"location":"user-guide/utils/math/#quaternion","title":"Quaternion","text":"<p>Our Quaternion class is adapted from Adafruit's <code>imu</code> namespace. It is used by the IMU to store orientation data. It supports vector operations such as addition, subtraction, and multiplication, as well as quaternion-specific operations like quaternion multiplication and conversion to/from Euler angles.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Create a quaternion with specific components (w, x, y, z)\nQuaternion q1 = Quaternion(1.0, 0.0, 0.0, 0.0);\n\n// Normalize the quaternion to ensure valid rotation data\nq1.normalize();\n\n// Convert to Euler angles (yaw, pitch, roll)\nVector&lt;3&gt; euler = q1.toEuler321();\n\n// Perform other quaternion operations here...\n</code></pre>"},{"location":"user-guide/utils/math/#vector","title":"Vector","text":"<p>The Vector class is used to represent a mathematical vector (not to be confused with the C++ <code>std::vector</code>). This Vector has a fixed length containing <code>double</code> values. It supports vector operations like addition, subtraction, multiplication, as well as dot products and cross products. It is also adapted from Adafruit's <code>imu</code> vector class.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Create two 3D vectors\nVector&lt;3&gt; v1 = Vector(1.0, 2.0, 3.0);\nVector&lt;3&gt; v2 = Vector(3.0, 2.0, 1.0);\n\n// Compute the dot product\ndouble dotVal = v1.dot(v2); // 1*3 + 2*2 + 3*1 = 3 + 4 + 3 = 10\n\n// Compute the cross product\nVector crossVal = v1.cross(v2); // (2*1 - 3*2, 3*3 - 1*1, 1*2 - 2*3)\n\n// Perform additional vector operations as needed...\n</code></pre>"},{"location":"user-guide/utils/mmfssys/","title":"MMFSSystem","text":"<p>The MMFSSystem object is designed to make interacting with the MMFS library as simple as possible. You begin by defining an MMFSConfig object, configuring all of the parameters your flight code needs, and then passing that configuration object into an MMFSSystem object. Afterward, you only need to call the <code>init()</code> and <code>update()</code> functions. MMFSSystem will take care of everything else.</p>"},{"location":"user-guide/utils/mmfssys/#mmfsconfig","title":"MMFSConfig","text":"<p>The MMFSConfig object uses a builder-like pattern, making it easy to set up MMFS. The only configuration option that you must use in order to run MMFSSystem is to pass a derived State object with proper launch detection.</p>"},{"location":"user-guide/utils/mmfssys/#code-example-withstate","title":"Code Example: <code>withState(...)</code>","text":"<pre><code>#include &lt;MMFS.h&gt;\n#include &lt;MyCustomState.h&gt; // A user-defined State class that detects launch\n\n\nMyCustomState myState;\n\nMMFSConfig config = MMFSConfig()\n                    .withState(&amp;myState); // REQUIRED\n</code></pre> <p>Where <code>myState</code> is your derived State object that handles launch detection.</p>"},{"location":"user-guide/utils/mmfssys/#mmfsconfig-options","title":"MMFSConfig Options","text":"<p>Below is a refined list of the configuration methods available in MMFSConfig. Each returns a reference to the same MMFSConfig instance, allowing you to chain calls together:</p> <ul> <li> <p><code>withState(State *state)</code>   Adds a derived State (and its associated sensors) to MMFS. This is required for MMFSSystem to function properly.</p> </li> <li> <p><code>withUpdateRate(unsigned int updateRate)</code>   Sets an update rate in Hertz. (Default is <code>10</code>.) Mutually exclusive with update interval.</p> </li> <li> <p><code>withUpdateInterval(unsigned int updateInterval)</code>   Sets the update interval in milliseconds. (Default is <code>100</code>.) Mutually exclusive with update rate.</p> </li> <li> <p><code>withSensorBiasCorrectionDataLength(unsigned int sensorBiasCorrectionDataLength)</code>   Specifies the duration (in seconds) over which sensors will average data to correct for drift. This duration is affected by the update rate/interval. (Default is <code>2</code>.)</p> </li> <li> <p><code>withSensorBiasCorrectionDataIgnore(unsigned int sensorBiasCorrectionDataIgnore)</code>   Specifies the duration (in seconds) of the most recent data to ignore when performing drift correction. This duration is also affected by the update rate/interval. (Default is <code>1</code>.)</p> </li> <li> <p><code>withUsingSensorBiasCorrection(bool useBiasCorrection)</code>   Determines whether sensors will continuously re-zero themselves while on the ground. (Default is <code>false</code>.) Warning: This function requires working launch detection or data may not be accurate.</p> </li> <li> <p><code>withBuzzerPin(unsigned int buzzerPin)</code>   Sets the named <code>BUZZER</code> for use with <code>BlinkBuzz</code>. (No Default.)</p> </li> <li> <p><code>withBBPin(unsigned int bbPin)</code>   Adds a pin to <code>BlinkBuzz</code>. By default, no pins are added.</p> </li> <li> <p><code>withBBAsync(bool bbAsync, unsigned int queueSize = 50)</code>   Allows <code>BlinkBuzz</code> to use asynchronous features. This incurs moderate memory overhead based on the queue size (the number of state changes a pin can queue). (Default is <code>true</code> and <code>50</code>.)</p> </li> <li> <p><code>withReducedPreFlightDataRate(bool useReducedRate, unsigned int secondsBetweenRecords)</code>   Enables or disables reduced data rates before flight. (Default is <code>true</code>, <code>30</code> seconds.) Warning: This requires working launch detection or all data will remain at the reduced rate.</p> </li> <li> <p><code>withOtherDataReporters(DataReporter **others)</code>   Adds additional DataReporter objects for flight data logging. Passing a State via <code>withState()</code> automatically captures that State\u2019s sensors, so adding them here might be redundant.</p> </li> <li> <p><code>withNoDefaultEventListener()</code>   Removes the default event handler from the event manager, useful if you have a custom one that alters default behavior.</p> </li> <li> <p><code>withLogPrefixFormatting(const char *prefix)</code>   Changes the formatting of the log prefix. You must use <code>$time</code> and <code>$logType</code> to reference the current log\u2019s time and log type. (Default is <code>\"$time - [$logType] \"</code>.)</p> </li> </ul>"},{"location":"user-guide/utils/mmfssys/#full-example","title":"Full Example","text":"<p>Below is a simple, hypothetical Arduino sketch illustrating how to use MMFSSystem with MMFSConfig:</p> <p><pre><code>#include &lt;Arduino.h&gt;\n#include &lt;MMFS.h&gt;\n#include &lt;MyCustomState.h&gt;  // Your derived State class\n#include &lt;MyCustomReporter.h&gt; // Additional DataReporter\n\n// Create instances\nMyCustomState myState;\nMyCustomReporter myReporter;\n\n// Create the configuration\nMMFSConfig config = MMFSConfig()\n    .withState(&amp;myState)    // Required for launch detection\n    .withUpdateRate(20)     // 20 Hz update\n    .withOtherDataReporters({&amp;myReporter}) // Additional data reporters\n    .withLogPrefixFormatting(\"$time - [$logType]: \");\n\n// Create the system object\nMMFSSystem system = MMFSSystem(config);\n\nvoid setup() {\n    Serial.begin(115200);\n    // Initialize the system\n    system.init(); // (1)!\n}\n\nvoid loop() {\n    // Update the system\n    system.update();\n\n    // Your other code goes here...\n}\n</code></pre></p> <ol> <li>This function will call events based on whether or not State and Logger initialize successfully. They are automatically handled by the default event listener.</li> </ol>"},{"location":"user-guide/utils/test/","title":"Test page","text":""}]}